use actix_web::{web, App, HttpServer, Responder, HttpResponse};
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::time::Duration;
use tokio::io::{AsyncBufReadExt, BufReader};
use reqwest;
use crossterm::{
event::{self, KeyCode, KeyEvent},
terminal::{self},
execute,
terminal::{Clear, ClearType},
cursor,
style::{Color, SetForegroundColor},
};
use std::io::{stdout, Write};
use std::error::Error;

const PORT: u16 = 8080;
const TIMEOUT: u64 = 100;

#[derive(Clone)]
struct Agent {
id: String,
address: String,
port: u16,
status: String,
}

impl Agent {
fn new(id: &str, address: &str, port: u16) -> Self {
Agent {
id: id.to_string(),
address: address.to_string(),
port,
status: "idle".to_string(),
}
}
}

#[derive(Clone)]
struct DataStore {
agents: Arc<Mutex<Vec<Agent>>>,
}

impl DataStore {
fn new() -> Self {
DataStore {
agents: Mutex::new(vec![
Agent::new("Agent1", "192.168.1.100", 8081),
Agent::new("Agent2", "192.168.1.101", 8082),
Agent::new("Agent3", "192.168.1.102", 8083),
]).into(),
}
}

async fn get_agent(&self, id: &str) -> Option<Agent> {
let mut agents = self.agents.lock().await;
agents.iter_mut().find(|a| a.id == id).cloned()
}
}

async fn handle_command(data: web::Data<DataStore>, agent_id: String, command: String) -> impl Responder {
if let Some(mut agent) = data.get_agent(&agent_id).await {
let client = reqwest::Client::new();
let _res = client.post(format!("http://{}:{}/command", agent.address, agent.port))
.body(command)
.send()
.await;
agent.status = "active".to_string();
HttpResponse::Ok().body(format!("Command sent to {}", agent.id))
} else {
HttpResponse::NotFound().body("Agent not found")
}
}

async fn handle_status(data: web::Data<DataStore>, agent_id: String) -> Result<HttpResponse, Box<dyn Error>> {
if let Some(agent) = data.get_agent(&agent_id).await {
let client = reqwest::Client::new();
let res = client.get(format!("http://{}:{}/status", agent.address, agent.port))
.send()
.await?;
let status = res.text().await?;
Ok(HttpResponse::Ok().body(format!("Status of {}: {}", agent.id, status)))
} else {
Ok(HttpResponse::NotFound().body("Agent not found"))
}
}

async fn handle_list(data: web::Data<DataStore>) -> impl Responder {
let agents = data.agents.lock().await;
let agent_ids: Vec<String> = agents.iter().map(|a| a.id.clone()).collect();
HttpResponse::Ok().json(agent_ids)
}

async fn start_server(data: web::Data<DataStore>) -> Result<actix_web::dev::Server, ServerError> {
let server = HttpServer::new(move || {
App::new()
.app_data(data.clone())
.route("/command/{id}/{command}", web::post().to(handle_command))
.route("/status/{id}", web::get().to(handle_status))
.route("/list", web::get().to(handle_list))
})
.bind(format!("127.0.0.1:{}", PORT))
.map_err(|e| ServerError { message: format!("Failed to bind: {}", e) })?;

Ok(server.run())
}

struct Tui {
prompt: String,
client: reqwest::Client,
command_history: Vec<String>,
history_index: usize,
}

impl Tui {
fn new() -> Self {
Self {
prompt: String::new(),
client: reqwest::Client::new(),
command_history: Vec::new(),
history_index: 0,
}
}

async fn start(&mut self, data: web::Data<DataStore>) -> Result<(), Box<dyn Error>> {
terminal::enable_raw_mode()?;
loop {
self.display_ui().await?;
if let Some(key_event) = self.get_input().await {
if let Err(e) = self.handle_input(key_event, data.clone()).await {
eprintln!("Error: {}", e);
break;
}
}
}
terminal::disable_raw_mode()?;
Ok(())
}

async fn display_ui(&self) -> Result<(), Box<dyn Error>> {
execute!(
stdout(),
Clear(ClearType::All),
cursor::MoveTo(0, 0),
SetForegroundColor(Color::Cyan),
)?;
println!("C2 Control Panel");
println!("--------------------");
println!("Commands: list, status, command, help, exit");
println!();
execute!(
stdout(),
SetForegroundColor(Color::White),
)?;
print!("> {}", self.prompt);
stdout().flush()?;
Ok(())
}

async fn get_input(&self) -> Option<KeyEvent> {
if event::poll(Duration::from_millis(TIMEOUT)).unwrap() {
if let event::Event::Key(key_event) = event::read().unwrap() {
return Some(key_event);
}
}
None
}

async fn handle_input(&mut self, key_event: KeyEvent, data: web::Data<DataStore>) -> Result<(), Box<dyn Error>> {
match key_event.code {
KeyCode::Esc | KeyCode::Char('q') => {
self.exit()?;
},
KeyCode::Enter => {
self.execute_command(data).await?;
},
KeyCode::Backspace => {
self.prompt.pop();
},
KeyCode::Up => {
self.navigate_history(true);
},
KeyCode::Down => {
self.navigate_history(false);
},
KeyCode::Char(c) => {
self.prompt.push(c);
},
_ => (),
}
Ok(())
}

fn navigate_history(&mut self, up: bool) {
if self.command_history.is_empty() {
return;
}
if up && self.history_index < self.command_history.len() {
self.history_index += 1;
} else if !up && self.history_index > 0 {
self.history_index -= 1;
}
if self.history_index > 0 {
self.prompt = self.command_history[self.command_history.len() - self.history_index].clone();
} else {
self.prompt.clear();
}
}

async fn execute_command(&mut self, _data: web::Data<DataStore>) -> Result<(), Box<dyn Error>> {
println!();
let command = self.prompt.trim();
if !command.is_empty() {
self.command_history.push(command.to_string());
self.history_index = 0;
}
match command {
"list" => {
self.list_agents().await?;
},
"status" => {
self.get_agent_status().await?;
},
"command" => {
self.send_command().await?;
},
"help" => {
self.show_help();
},
"exit" => {
self.exit()?;
},
_ => println!("Unknown command. Type 'help' for available commands."),
}
self.prompt.clear();
println!("\nPress any key to continue...");
self.wait_for_key().await;
Ok(())
}

async fn list_agents(&self) -> Result<(), Box<dyn Error>> {
let res = self.client.get(format!("http://localhost:{}/list", PORT))
.send()
.await?;
let agents: Vec<String> = res.json().await?;
println!("Agents:");
for agent in agents {
println!("- {}", agent);
}
Ok(())
}

async fn get_agent_status(&self) -> Result<(), Box<dyn Error>> {
print!("Enter agent ID: ");
stdout().flush().unwrap();
let agent_id = self.read_line().await?;
let res = self.client.get(format!("http://localhost:{}/status/{}", PORT, agent_id))
.send()
.await?;
println!("{}", res.text().await?);
Ok(())
}

async fn send_command(&self) -> Result<(), Box<dyn Error>> {
print!("Enter agent ID: ");
stdout().flush().unwrap();
let agent_id = self.read_line().await?;
print!("Enter command: ");
stdout().flush().unwrap();
let command = self.read_line().await?;
let res = self.client.post(format!("http://localhost:{}/command/{}/{}", PORT, agent_id, command))
.send()
.await?;
println!("{}", res.text().await?);
Ok(())
}

fn show_help(&self) {
println!("Available commands:");
println!(" list - List all agents");
println!(" status - Get the status of a specific agent");
println!(" command - Send a command to a specific agent");
println!(" help - Show this help message");
println!(" exit - Exit the program");
}

fn exit(&self) -> Result<(), Box<dyn Error>> {
terminal::disable_raw_mode()?;
execute!(
stdout(),
Clear(ClearType::All),
cursor::MoveTo(0, 0),
)?;
std::process::exit(0);
}

async fn read_line(&self) -> Result<String, Box<dyn Error>> {
let mut input = String::new();
let mut reader = BufReader::new(tokio::io::stdin());
reader.read_line(&mut input).await?;
Ok(input.trim().to_string())
}

async fn wait_for_key(&self) {
loop {
if let Some(_) = self.get_input().await {
break;
}
}
}
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
let data_store = web::Data::new(DataStore::new());

// Start the server
let server = start_server(data_store.clone()).await?;

// Run the server in the background
let server_handle = tokio::spawn(server);

// Start the TUI interface
let mut tui = Tui::new();
let tui_result = tui.start(data_store).await;

// Ensure the server is properly shut down
server_handle.abort();
let _ = server_handle.await;

// Propagate any errors from the TUI
tui_result?;

Ok(())
}

// Add this custom error type
#[derive(Debug)]
struct ServerError {
message: String,
}

impl std::fmt::Display for ServerError {
fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
write!(f, "Server error: {}", self.message)
}
}

impl std::error::Error for ServerError {}  
