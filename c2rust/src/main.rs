use actix_web::{web, App, HttpServer, Responder, HttpResponse};
use std::sync::Arc;
use tokio::sync::Mutex;
use tokio::time::Duration;
use tokio::io::{AsyncBufReadExt, BufReader};
use reqwest;
use crossterm::{
    event::{self, KeyCode, KeyEvent},
    terminal::{self},
    execute,
    terminal::{Clear, ClearType},
    cursor,
    style::{Color, SetForegroundColor},
};
use std::io::{stdout, Write};

const PORT: u16 = 8080;
const TIMEOUT: u64 = 100;

#[derive(Clone)]
struct Agent {
    id: String,
    status: String,
}

impl Agent {
    fn new(id: &str) -> Self {
        Agent {
            id: id.to_string(),
            status: "idle".to_string(),
        }
    }

    fn update_status(&mut self, status: &str) {
        self.status = status.to_string();
    }
}

#[derive(Clone)]
struct DataStore {
    agents: Vec<Agent>,
}

impl DataStore {
    fn new() -> Self {
        DataStore {
            agents: vec![
                Agent::new("Agent1"),
                Agent::new("Agent2"),
                Agent::new("Agent3"),
            ],
        }
    }

    fn get_agent(&mut self, id: &str) -> Option<&mut Agent> {
        self.agents.iter_mut().find(|a| a.id == id)
    }
}

async fn handle_command(data: web::Data<Arc<Mutex<DataStore>>>, agent_id: String) -> impl Responder {
    let mut data = data.lock().await;
    if let Some(agent) = data.get_agent(&agent_id) {
        agent.update_status("active");
        return HttpResponse::Ok().body(format!("Command sent to {}", agent.id));
    }
    HttpResponse::NotFound().body("Agent not found")
}

async fn handle_status(data: web::Data<Arc<Mutex<DataStore>>>, agent_id: String) -> impl Responder {
    let mut data = data.lock().await;
    if let Some(agent) = data.get_agent(&agent_id) {
        return HttpResponse::Ok().body(format!("Status of {}: {}", agent.id, agent.status));
    }
    HttpResponse::NotFound().body("Agent not found")
}

async fn handle_list(data: web::Data<Arc<Mutex<DataStore>>>) -> impl Responder {
    let data = data.lock().await;
    let agents: Vec<String> = data.agents.iter().map(|a| a.id.clone()).collect();
    HttpResponse::Ok().json(agents)
}

async fn start_server(data: Arc<Mutex<DataStore>>) -> std::io::Result<()> {
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(data.clone()))
            .route("/command/{id}", web::post().to(handle_command))
            .route("/status/{id}", web::get().to(handle_status))
            .route("/list", web::get().to(handle_list))
    })
    .bind(format!("127.0.0.1:{}", PORT))?
    .run()
    .await
}

struct Tui {
    prompt: String,
    client: reqwest::Client,
    command_history: Vec<String>,
    history_index: usize,
}

impl Tui {
    fn new() -> Self {
        Self {
            prompt: String::new(),
            client: reqwest::Client::new(),
            command_history: Vec::new(),
            history_index: 0,
        }
    }

    async fn start(&mut self, data: Arc<Mutex<DataStore>>) {
        terminal::enable_raw_mode().unwrap();
        loop {
            self.display_ui().await;
            if let Some(key_event) = self.get_input().await {
                self.handle_input(key_event, data.clone()).await;
            }
        }
    }

    async fn display_ui(&self) {
        execute!(
            stdout(),
            Clear(ClearType::All),
            cursor::MoveTo(0, 0),
            SetForegroundColor(Color::Cyan),
        ).unwrap();
        println!("C2 Control Panel");
        println!("--------------------");
        println!("Commands: list, status, command, help, exit");
        println!();
        execute!(
            stdout(),
            SetForegroundColor(Color::White),
        ).unwrap();
        print!("> {}", self.prompt);
        stdout().flush().unwrap();
    }

    async fn get_input(&self) -> Option<KeyEvent> {
        if event::poll(Duration::from_millis(TIMEOUT)).unwrap() {
            if let event::Event::Key(key_event) = event::read().unwrap() {
                return Some(key_event);
            }
        }
        None
    }

    async fn handle_input(&mut self, key_event: KeyEvent, data: Arc<Mutex<DataStore>>) {
        match key_event.code {
            KeyCode::Esc | KeyCode::Char('q') => {
                self.exit();
            },
            KeyCode::Enter => {
                self.execute_command(data).await;
            },
            KeyCode::Backspace => {
                self.prompt.pop();
            },
            KeyCode::Up => {
                self.navigate_history(true);
            },
            KeyCode::Down => {
                self.navigate_history(false);
            },
            KeyCode::Char(c) => {
                self.prompt.push(c);
            },
            _ => (),
        }
    }

    fn navigate_history(&mut self, up: bool) {
        if self.command_history.is_empty() {
            return;
        }
        if up && self.history_index < self.command_history.len() {
            self.history_index += 1;
        } else if !up && self.history_index > 0 {
            self.history_index -= 1;
        }
        if self.history_index > 0 {
            self.prompt = self.command_history[self.command_history.len() - self.history_index].clone();
        } else {
            self.prompt.clear();
        }
    }

    async fn execute_command(&mut self, _data: Arc<Mutex<DataStore>>) {
        println!();
        let command = self.prompt.trim();
        if !command.is_empty() {
            self.command_history.push(command.to_string());
            self.history_index = 0;
        }
        match command {
            "list" => {
                self.list_agents().await;
            },
            "status" => {
                self.get_agent_status().await;
            },
            "command" => {
                self.send_command().await;
            },
            "help" => {
                self.show_help();
            },
            "exit" => {
                self.exit();
            },
            _ => println!("Unknown command. Type 'help' for available commands."),
        }
        self.prompt.clear();
        println!("\nPress any key to continue...");
        self.wait_for_key().await;
    }

    async fn list_agents(&self) {
        let res = self.client.get(format!("http://localhost:{}/list", PORT))
            .send()
            .await
            .unwrap()
            .json::<Vec<String>>()
            .await
            .unwrap();
        println!("Agents:");
        for agent in res {
            println!("- {}", agent);
        }
    }

    async fn get_agent_status(&self) {
        print!("Enter agent ID: ");
        stdout().flush().unwrap();
        let agent_id = self.read_line().await;
        let res = self.client.get(format!("http://localhost:{}/status/{}", PORT, agent_id))
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();
        println!("{}", res);
    }

    async fn send_command(&self) {
        print!("Enter agent ID: ");
        stdout().flush().unwrap();
        let agent_id = self.read_line().await;
        let res = self.client.post(format!("http://localhost:{}/command/{}", PORT, agent_id))
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();
        println!("{}", res);
    }

    fn show_help(&self) {
        println!("Available commands:");
        println!("  list    - List all agents");
        println!("  status  - Get the status of a specific agent");
        println!("  command - Send a command to a specific agent");
        println!("  help    - Show this help message");
        println!("  exit    - Exit the program");
    }

    fn exit(&self) {
        terminal::disable_raw_mode().unwrap();
        execute!(
            stdout(),
            Clear(ClearType::All),
            cursor::MoveTo(0, 0),
        ).unwrap();
        std::process::exit(0);
    }

    async fn read_line(&self) -> String {
        let mut input = String::new();
        let mut reader = BufReader::new(tokio::io::stdin());
        reader.read_line(&mut input).await.unwrap();
        input.trim().to_string()
    }

    async fn wait_for_key(&self) {
        loop {
            if self.get_input().await.is_some() {
                break;
            }
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let data_store = Arc::new(Mutex::new(DataStore::new()));
    
    // Start the server asynchronously in the background
    let data_store_clone = data_store.clone();
    actix_web::rt::spawn(async move {
        start_server(data_store_clone).await.unwrap();
    });

    // Start the TUI interface
    let mut tui = Tui::new();
    tui.start(data_store).await;
    Ok(())
}