import argparse
import os
import random
import struct
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

# Define the Metamorphic Engine class
class MetamorphicEngine:
    def __init__(self, input_file, output_file, options):
        self.input_file = input_file
        self.output_file = output_file
        self.options = options
        self.console = Console()
        self.file_data = None

    def read_file(self):
        self.console.print(f"[bold green]Reading file:[/bold green] {self.input_file}")
        try:
            if not os.path.isfile(self.input_file):
                raise FileNotFoundError(f"{self.input_file} does not exist.")
            
            with open(self.input_file, 'rb') as f:
                self.file_data = f.read()
            self.console.print(f"[bold green]Successfully read file.[/bold green]")
        except FileNotFoundError as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")
            raise
        except IOError as e:
            self.console.print(f"[bold red]IOError:[/bold red] {e}")
            raise

    def write_file(self):
        self.console.print(f"[bold green]Writing obfuscated file to:[/bold green] {self.output_file}")
        try:
            with open(self.output_file, 'wb') as f:
                f.write(self.file_data)
            self.console.print(f"[bold green]Successfully wrote file.[/bold green]")
        except IOError as e:
            self.console.print(f"[bold red]IOError:[/bold red] {e}")
            raise

    def reorder_code(self):
        if self.options['Reorder Code']:
            self.console.print("[bold blue]Reordering code...[/bold blue]")
            self.file_data = bytearray(self.file_data)
            random.shuffle(self.file_data)  # Simplified example of reordering
            self.console.print("[bold green]Code reordered.[/bold green]")

    def substitute_instructions(self):
        if self.options['Substitute Instructions']:
            self.console.print("[bold blue]Substituting instructions...[/bold blue]")
            # Placeholder for actual instruction substitution logic
            self.console.print("[bold green]Instructions substituted.[/bold green]")

    def insert_garbage_code(self):
        if self.options['Insert Garbage Code']:
            self.console.print("[bold blue]Inserting garbage code...[/bold blue]")
            garbage_code = b'\x90' * 1024  # NOP sled as garbage code example
            self.file_data += garbage_code
            self.console.print("[bold green]Garbage code inserted.[/bold green]")

    def insert_anti_debugging(self):
        if self.options['Insert Anti-Debugging']:
            self.console.print("[bold blue]Inserting anti-debugging techniques...[/bold blue]")
            # Placeholder for anti-debugging techniques
            self.console.print("[bold green]Anti-debugging techniques inserted.[/bold green]")

    def generate_dynamic_code(self):
        if self.options['Generate Dynamic Code']:
            self.console.print("[bold blue]Generating dynamic code...[/bold blue]")
            # Placeholder for dynamic code generation
            self.console.print("[bold green]Dynamic code generated.[/bold green]")

    def apply_code_transformation(self):
        if self.options['Apply Code Transformation']:
            self.console.print("[bold blue]Applying code transformations...[/bold blue]")
            # Placeholder for code transformation logic
            self.console.print("[bold green]Code transformations applied.[/bold green]")

    def encrypt_code(self):
        if self.options['Encrypt Code']:
            self.console.print("[bold blue]Encrypting code...[/bold blue]")
            # Placeholder for encryption logic
            self.console.print("[bold green]Code encrypted.[/bold green]")

    def add_stack_smashing_protection(self):
        if self.options['Add Stack Smashing Protection']:
            self.console.print("[bold blue]Adding stack smashing protection...[/bold blue]")
            # Placeholder for stack smashing protection logic
            self.console.print("[bold green]Stack smashing protection added.[/bold green]")

    def include_anti_reverse_engineering(self):
        if self.options['Include Anti-Reverse Engineering']:
            self.console.print("[bold blue]Including anti-reverse engineering techniques...[/bold blue]")
            # Placeholder for anti-reverse engineering techniques
            self.console.print("[bold green]Anti-reverse engineering techniques included.[/bold green]")

    def insert_nop_sleds(self):
        if self.options['Insert NOP Sleds']:
            self.console.print("[bold blue]Inserting NOP sleds...[/bold blue]")
            nop_sled = b'\x90' * 512
            self.file_data += nop_sled
            self.console.print("[bold green]NOP sleds inserted.[/bold green]")

    def insert_rop_chains(self):
        if self.options['Insert ROP Chains']:
            self.console.print("[bold blue]Inserting ROP chains...[/bold blue]")
            # Placeholder for ROP chains
            self.console.print("[bold green]ROP chains inserted.[/bold green]")

    def duplicate_stack_frames(self):
        if self.options['Duplicate Stack Frames']:
            self.console.print("[bold blue]Duplicating stack frames...[/bold blue]")
            # Placeholder for stack frame duplication
            self.console.print("[bold green]Stack frames duplicated.[/bold green]")

    def include_vm_code(self):
        if self.options['Include VM Code']:
            self.console.print("[bold blue]Including VM code...[/bold blue]")
            # Placeholder for VM code
            self.console.print("[bold green]VM code included.[/bold green]")

    def obfuscate(self):
        self.read_file()
        if self.options['Reorder Code']:
            self.reorder_code()
        if self.options['Substitute Instructions']:
            self.substitute_instructions()
        if self.options['Insert Garbage Code']:
            self.insert_garbage_code()
        if self.options['Insert Anti-Debugging']:
            self.insert_anti_debugging()
        if self.options['Generate Dynamic Code']:
            self.generate_dynamic_code()
        if self.options['Apply Code Transformation']:
            self.apply_code_transformation()
        if self.options['Encrypt Code']:
            self.encrypt_code()
        if self.options['Add Stack Smashing Protection']:
            self.add_stack_smashing_protection()
        if self.options['Include Anti-Reverse Engineering']:
            self.include_anti_reverse_engineering()
        if self.options['Insert NOP Sleds']:
            self.insert_nop_sleds()
        if self.options['Insert ROP Chains']:
            self.insert_rop_chains()
        if self.options['Duplicate Stack Frames']:
            self.duplicate_stack_frames()
        if self.options['Include VM Code']:
            self.include_vm_code()
        self.write_file()

    def display_options(self):
        table = Table(title="Options and Settings")
        table.add_column("Option", style="bold")
        table.add_column("Enabled", style="bold")

        for option, enabled in self.options.items():
            table.add_row(option, "Yes" if enabled else "No")
        
        self.console.print(Panel(table, title="Options and Settings", title_align="left"))

    def display_best_practices(self):
        practices = [
            "Reordering code - Helps to break patterns and make reverse engineering harder.",
            "Substituting instructions - Replaces instructions with functionally equivalent alternatives.",
            "Inserting garbage code - Adds non-functional code to confuse disassemblers.",
            "Anti-debugging techniques - Prevents debugging and reverse engineering.",
            "Dynamic code generation - Creates and executes code at runtime.",
            "Code transformations - Applies transformations to the code for additional obfuscation.",
            "Encryption - Encrypts code to prevent static analysis.",
            "Stack smashing protection - Adds stack canaries to prevent stack overflow attacks.",
            "Anti-reverse engineering techniques - Techniques to thwart reverse engineering efforts.",
            "NOP sleds - Adds NOP instructions to make certain code areas more resilient.",
            "ROP chains - Adds Return-Oriented Programming chains to obfuscate execution flow.",
            "Duplicate stack frames - Duplicates stack frames to confuse stack-based attacks.",
            "Virtual machine code - Includes VM code to add an additional layer of obfuscation.",
        ]

        self.console.print(Panel("\n".join(f"{i+1}. {p}" for i, p in enumerate(practices)), title="Best Practices for Obfuscation", title_align="left"))

# Define the main function
def main():
    parser = argparse.ArgumentParser(description="Metamorphic Code Obfuscation Tool")
    parser.add_argument('input_file', type=str, help='Path to the input binary file')
    parser.add_argument('output_file', type=str, help='Path to save the obfuscated output file')
    parser.add_argument('--reorder', action='store_true', help='Reorder code')
    parser.add_argument('--substitute', action='store_true', help='Substitute instructions')
    parser.add_argument('--garbage', action='store_true', help='Insert garbage code')
    parser.add_argument('--anti-debug', action='store_true', help='Insert anti-debugging techniques')
    parser.add_argument('--dynamic', action='store_true', help='Generate dynamic code')
    parser.add_argument('--transform', action='store_true', help='Apply code transformations')
    parser.add_argument('--encrypt', action='store_true', help='Encrypt code')
    parser.add_argument('--stack-smash', action='store_true', help='Add stack smashing protection')
    parser.add_argument('--anti-re', action='store_true', help='Include anti-reverse engineering techniques')
    parser.add_argument('--nop-sled', action='store_true', help='Insert NOP sleds')
    parser.add_argument('--rop-chains', action='store_true', help='Insert ROP chains')
    parser.add_argument('--dup-frames', action='store_true', help='Duplicate stack frames')
    parser.add_argument('--vm-code', action='store_true', help='Include VM code')
    
    args = parser.parse_args()

    options = {
        'Reorder Code': args.reorder,
        'Substitute Instructions': args.substitute,
        'Insert Garbage Code': args.garbage,
        'Insert Anti-Debugging': args.anti_debug,
        'Generate Dynamic Code': args.dynamic,
        'Apply Code Transformation': args.transform,
        'Encrypt Code': args.encrypt,
        'Add Stack Smashing Protection': args.stack_smash,
        'Include Anti-Reverse Engineering': args.anti_re,
        'Insert NOP Sleds': args.nop_sled,
        'Insert ROP Chains': args.rop_chains,
        'Duplicate Stack Frames': args.dup_frames,
        'Include VM Code': args.vm_code,
    }

    engine = MetamorphicEngine(args.input_file, args.output_file, options)
    
    engine.display_options()
    engine.display_best_practices()
    engine.obfuscate()

if __name__ == "__main__":
    main()

