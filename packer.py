#import base64
#import os
import random
import string
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

#class PayloadObfuscatorPacker:
   # def __init__(self, aes_key: bytes, rsa_key_pair):
        self.aes_key = aes_key
        self.rsa_public_key, self.rsa_private_key = rsa_key_pair
        self.cipher_aes = AES.new(self.aes_key, AES.MODE_CBC)
        self.iv = self.cipher_aes.iv
        self.cipher_rsa = PKCS1_OAEP.new(self.rsa_public_key)
        self.cipher_rsa_private = PKCS1_OAEP.new(self.rsa_private_key)

    def obfuscate(self, payload: str) -> str:
        encrypted_payload = self.encrypt_payload(payload)
        fragmented_payload = self.fragment_payload(encrypted_payload)
        obfuscated_payload = self.insert_dynamic_dummy_code(fragmented_payload)
        dynamic_payload = self.add_dynamic_behavior(obfuscated_payload)
        return dynamic_payload

    def deobfuscate(self, obfuscated_payload: str) -> str:
        payload_with_metadata = self.remove_dynamic_dummy_code(obfuscated_payload)
        decrypted_payload = self.decrypt_payload(payload_with_metadata)
        return decrypted_payload

    def encrypt_payload(self, data: str) -> str:
        cipher = AES.new(self.aes_key, AES.MODE_CBC, self.iv)
        padded_data = pad(data.encode(), AES.block_size)
        encrypted_data = cipher.encrypt(padded_data)
        encrypted_data_with_iv = self.iv + encrypted_data
        encrypted_aes_key = self.cipher_rsa.encrypt(self.aes_key)
        combined_encrypted_data = encrypted_aes_key + encrypted_data_with_iv
        return self.custom_base64_encode(combined_encrypted_data)

    #def decrypt_payload(self, encrypted_data: str) -> str:
        combined_encrypted_data = self.custom_base64_decode(encrypted_data)
        encrypted_aes_key = combined_encrypted_data[:256]
        encrypted_data_with_iv = combined_encrypted_data[256:]
        decrypted_aes_key = self.cipher_rsa_private.decrypt(encrypted_aes_key)
        cipher = AES.new(decrypted_aes_key, AES.MODE_CBC, encrypted_data_with_iv[:AES.block_size])
        encrypted_data = encrypted_data_with_iv[AES.block_size:]
        decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size)
        return decrypted_data.decode()

    def custom_base64_encode(self, data: bytes) -> str:
        encoded = base64.b64encode(data).decode()
        return 'ENC:' + encoded[::-1]

    def custom_base64_decode(self, data: str) -> bytes:
        encoded = data[4:][::-1]
        return base64.b64decode(encoded)

    def fragment_payload(self, payload: str) -> str:
        fragment_size = random.randint(50, 150)
        fragments = [payload[i:i + fragment_size] for i in range(0, len(payload), fragment_size)]
        return '\n'.join(fragments)

    def insert_dynamic_dummy_code(self, payload: str) -> str:
        dummy_code = self.generate_dynamic_dummy_code()
        return f"{dummy_code}\n{payload}\n{dummy_code}"

    def remove_dynamic_dummy_code(self, payload: str) -> str:
        lines = payload.split('\n')
        return '\n'.join(line for line in lines if not self.is_dynamic_dummy_code(line))

    def generate_dynamic_dummy_code(self) -> str:
        return ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=30))

    def is_dynamic_dummy_code(self, line: str) -> bool:
        return len(line) == 30 and any(c in string.punctuation for c in line)

    def add_dynamic_behavior(self, payload: str) -> str:
        dynamic_behavior_code = self.generate_dynamic_behavior_code()
        return f"{dynamic_behavior_code}\n{payload}\n{dynamic_behavior_code}"

    def generate_dynamic_behavior_code(self) -> str:
        behavior_code = """
import time
print("Dynamic behavior execution started...")
time.sleep(2)
print("Dynamic behavior execution completed.")
"""
        return behavior_code

def generate_rsa_key_pair() -> tuple:
    key = RSA.generate(2048)
    private_key = key
    public_key = key.publickey()
    return (public_key, private_key)

#def main():
    try:
        aes_key = os.urandom(32)
        rsa_key_pair = generate_rsa_key_pair()
        obfuscator = PayloadObfuscatorPacker(aes_key, rsa_key_pair)

        payload = "This is a highly sensitive and secret payload!"
        print(f"Original Payload: {payload}")

        obfuscated_payload = obfuscator.obfuscate(payload)
        print(f"Obfuscated Payload: {obfuscated_payload}")

        deobfuscated_payload = obfuscator.deobfuscate(obfuscated_payload)
        print(f"Deobfuscated Payload: {deobfuscated_payload}")

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
