#include <iostream>
#include <vector>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <stdexcept>

// Function to print shellcode in raw byte array format
void print_raw_bytes(const std::vector<unsigned char>& shellcode) {
    std::cout << "Raw Byte Array:" << std::endl;
    std::cout << "unsigned char shellcode[] = {";
    for (size_t i = 0; i < shellcode.size(); ++i) {
        if (i > 0) std::cout << ", ";
        std::cout << "0x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(shellcode[i]);
    }
    std::cout << "};" << std::endl;
}

// Function to print shellcode in hexadecimal representation
void print_hex(const std::vector<unsigned char>& shellcode) {
    std::cout << "Hexadecimal Representation:" << std::endl;
    for (size_t i = 0; i < shellcode.size(); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(shellcode[i]);
    }
    std::cout << std::endl;
}

// Function to print shellcode in C-style string format
void print_c_style_string(const std::vector<unsigned char>& shellcode) {
    std::cout << "C-Style String Format:" << std::endl;
    std::cout << "unsigned char shellcode[] = \"";
    for (size_t i = 0; i < shellcode.size(); ++i) {
        if (shellcode[i] >= 32 && shellcode[i] <= 126) {
            std::cout << shellcode[i];
        } else {
            std::cout << "\\x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(shellcode[i]);
        }
    }
    std::cout << "\";" << std::endl;
}

// Function to convert a string of hex characters to a vector of bytes
std::vector<unsigned char> hex_to_bytes(const std::string& hex) {
    if (hex.length() % 2 != 0) {
        throw std::invalid_argument("Hex string length must be even.");
    }

    std::vector<unsigned char> bytes(hex.length() / 2);
    for (size_t i = 0; i < hex.length(); i += 2) {
        std::string byteString = hex.substr(i, 2);
        bytes[i / 2] = static_cast<unsigned char>(std::stoi(byteString, nullptr, 16));
    }
    return bytes;
}

// Main function to handle user input and shellcode generation
int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <format> [shellcode]" << std::endl;
        std::cerr << "Formats: raw, hex, c" << std::endl;
        return EXIT_FAILURE;
    }

    std::string format = argv[1];
    std::vector<unsigned char> shellcode;

    if (argc >= 3) {
        try {
            shellcode = hex_to_bytes(argv[2]);
        } catch (const std::invalid_argument& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            return EXIT_FAILURE;
        }
    } else {
        // Default shellcode (NOP sled + simple shellcode)
        shellcode = {
            0x90, 0x90, 0x90, 0x90, 0x90, // NOP sled
            0xB8, 0x04, 0x00, 0x00, 0x00, // mov eax, 4
            0xBF, 0x01, 0x00, 0x00, 0x00, // mov edi, 1
            0xB9, 0x00, 0x00, 0x00, 0x00, // mov ecx, 0
            0xBA, 0x00, 0x00, 0x00, 0x00, // mov edx, 0
            0xCD, 0x80,                     // int 0x80 (syscall)
            0xC3                            // ret
        };
    }

    if (format == "raw") {
        print_raw_bytes(shellcode);
    } else if (format == "hex") {
        print_hex(shellcode);
    } else if (format == "c") {
        print_c_style_string(shellcode);
    } else {
        std::cerr << "Unknown format: " << format << std::endl;
        std::cerr << "Valid formats are: raw, hex, c" << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
