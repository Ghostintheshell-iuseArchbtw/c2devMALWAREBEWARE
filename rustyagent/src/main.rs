use sysinfo::{System, SystemExt, CpuExt};
use tokio::{task, time};
use std::time::Duration;
use prometheus::{Encoder, TextEncoder, register_counter, register_histogram, Counter, Histogram};
use lazy_static::lazy_static;
use std::error::Error;

// Prometheus metrics
lazy_static! {
    static ref CPU_USAGE: Histogram = register_histogram!(
        "agent_cpu_usage",
        "Tracks CPU usage percentages"
    ).unwrap();

    static ref MEMORY_USAGE: Counter = register_counter!(
        "agent_memory_usage",
        "Tracks the amount of memory used"
    ).unwrap();
}

async fn gather_system_info() {
    // Create a new System instance to get system info
    let mut system = System::new_all();
    system.refresh_all();

    // Display CPU and memory information, and update Prometheus metrics
    for cpu in system.cpus() {
        let usage = cpu.cpu_usage();
        println!("CPU: {} | Usage: {}%", cpu.name(), usage);
        CPU_USAGE.observe(usage as f64); // Log CPU usage to Prometheus
    }

    let total_memory = system.total_memory();
    let used_memory = system.used_memory();
    println!("Total memory: {} KB", total_memory);
    println!("Used memory: {} KB", used_memory);
    MEMORY_USAGE.inc_by(used_memory as f64); // Log memory usage to Prometheus
}

async fn log_metrics() -> Result<(), Box<dyn Error>> {
    loop {
        // Encode metrics and print them for demonstration (this could be an HTTP export in real use)
        let encoder = TextEncoder::new();
        let metric_families = prometheus::gather();
        let mut buffer = Vec::new();
        encoder.encode(&metric_families, &mut buffer)?;
        println!("{}", String::from_utf8(buffer)?);

        // Sleep for 10 seconds before logging metrics again
        time::sleep(Duration::from_secs(10)).await;
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Spawn system information gathering as a background task
    let sys_info_task = task::spawn(async {
        loop {
            gather_system_info().await;
            time::sleep(Duration::from_secs(5)).await; // Gather info every 5 seconds
        }
    });

    // Spawn the Prometheus metrics logger as another background task
    let metrics_task = task::spawn(async {
        log_metrics().await.unwrap();
    });

    // Wait for both tasks to complete (they will run indefinitely)
    let _ = tokio::join!(sys_info_task, metrics_task);

    Ok(())
}

