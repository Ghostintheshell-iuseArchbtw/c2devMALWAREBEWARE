#include <iostream>
#include <vector>
#include <openssl/aes.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/rand.h>                                         
#include <openssl/bio.h>                                               
#include <openssl/buffer.h>                                            
#include <openssl/evp.h>                                               
#include <string>                                                      
#include <cstdlib>                                                     
#include <ctime>                                                             
#include <algorithm>                                                                
                                                                                    
class PayloadObfuscatorPacker {                                                              
public:                                                                                      
    PayloadObfuscatorPacker(const std::vector<unsigned char>& aes_key, RSA* rsa_public_key, RSA* rsa_private_key)                                                                         
        : aes_key_(aes_key), rsa_public_key_(rsa_public_key), rsa_private_key_(rsa_private_key) {
        iv_.resize(AES_BLOCK_SIZE);
        if (RAND_bytes(iv_.data(), iv_.size()) != 1) {
            throw std::runtime_error("Error generating random bytes for IV.");
        }
    }

    std::string obfuscate(const std::string& payload) {
        std::vector<unsigned char> encrypted_payload = encrypt_payload(payload);
        std::string fragmented_payload = fragment_payload(encrypted_payload);
        std::string obfuscated_payload = insert_dynamic_dummy_code(fragmented_payload);
        return add_dynamic_behavior(obfuscated_payload);
    }

    std::string deobfuscate(const std::string& obfuscated_payload) {
        std::string payload_with_metadata = remove_dynamic_dummy_code(obfuscated_payload);
        std::string decrypted_payload = decrypt_payload(payload_with_metadata);
        return decrypted_payload;
    }

private:
    std::vector<unsigned char> aes_key_;
    RSA* rsa_public_key_;
    RSA* rsa_private_key_;
    std::vector<unsigned char> iv_;

    std::vector<unsigned char> encrypt_payload(const std::string& data) {
        AES_KEY encrypt_key;
        if (AES_set_encrypt_key(reinterpret_cast<const unsigned char*>(aes_key_.data()), 256, &encrypt_key) != 0) {
            throw std::runtime_error("Error setting AES encryption key.");
        }

        std::vector<unsigned char> padded_data((data.size() + AES_BLOCK_SIZE - 1) / AES_BLOCK_SIZE * AES_BLOCK_SIZE);
        std::copy(data.begin(), data.end(), padded_data.begin());

        std::vector<unsigned char> encrypted_data_with_iv(AES_BLOCK_SIZE + padded_data.size());
        std::copy(iv_.begin(), iv_.end(), encrypted_data_with_iv.begin());

        AES_cbc_encrypt(padded_data.data(), encrypted_data_with_iv.data() + AES_BLOCK_SIZE,
                        padded_data.size(), &encrypt_key, iv_.data(), AES_ENCRYPT);

        std::vector<unsigned char> encrypted_aes_key(RSA_size(rsa_public_key_));
        if (RSA_public_encrypt(aes_key_.size(), reinterpret_cast<const unsigned char*>(aes_key_.data()), encrypted_aes_key.data(), rsa_public_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error encrypting AES key.");
        }

        std::vector<unsigned char> combined_encrypted_data;
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_aes_key.begin(), encrypted_aes_key.end());
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_data_with_iv.begin(), encrypted_data_with_iv.end());

        return custom_base64_encode(combined_encrypted_data);
    }

    std::string decrypt_payload(const std::string& encrypted_data) {
        std::vector<unsigned char> combined_encrypted_data = custom_base64_decode(encrypted_data);

        size_t aes_key_size = RSA_size(rsa_private_key_);
        std::vector<unsigned char> encrypted_aes_key(combined_encrypted_data.begin(), combined_encrypted_data.begin() + aes_key_size);
        std::vector<unsigned char> encrypted_data_with_iv(combined_encrypted_data.begin() + aes_key_size, combined_encrypted_data.end());

        std::vector<unsigned char> decrypted_aes_key(aes_key_.size());
        if (RSA_private_decrypt(encrypted_aes_key.size(), encrypted_aes_key.data(), decrypted_aes_key.data(), rsa_private_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error decrypting AES key.");
        }

        AES_KEY decrypt_key;
        if (AES_set_decrypt_key(reinterpret_cast<const unsigned char*>(decrypted_aes_key.data()), 256, &decrypt_key) != 0) {
            throw std::runtime_error("Error setting AES decryption key.");
        }

        std::vector<unsigned char> iv(AES_BLOCK_SIZE);
        std::copy(encrypted_data_with_iv.begin(), encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, iv.begin());
        std::vector<unsigned char> encrypted_data_part(encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, encrypted_data_with_iv.end());

        std::vector<unsigned char> decrypted_data(encrypted_data_part.size());
        AES_cbc_encrypt(encrypted_data_part.data(), decrypted_data.data(), encrypted_data_part.size(), &decrypt_key, iv.data(), AES_DECRYPT);

        return std::string(decrypted_data.begin(), decrypted_data.end());
    }

    std::string custom_base64_encode(const std::vector<unsigned char>& data) {
        BIO* bio_mem = BIO_new(BIO_s_mem());
        BIO* bio_b64 = BIO_new(BIO_f_base64());
        bio_mem->attach(static_cast<void*>(const_cast<unsigned char*>(data.data())), data.size());

        if (bio_b64 != NULL && bio_mem != NULL) {
            BIO_push(bio_b64, bio_mem);
            char encoded_data[4096];
            int len = BIO_write(bio_b64, encoded_data, 4096);
            BIO_flush(bio_b64);
            std::string encoded_string(encoded_data, static_cast<size_t>(len));
            BIO_free_all(bio_b64);
            return encoded_string;
        } else {
            throw std::runtime_error("Error encoding data with Base64.");
        }
    }

    std::vector<unsigned char> custom_base64_decode(const std::string& data) {
        BIO* bio_mem = BIO_new(BIO_s_mem());
        bio_mem->attach(static_cast<void*>(const_cast<char*>(data.c_str())), static_cast<int>(data.length()));

        BIO* bio_b64 = BIO_new(BIO_f_base64());
        BIO_push(bio_b64, bio_mem);

        std::vector<unsigned char> decoded_data(4096);
        int len = BIO_read(bio_b64, decoded_data.data(), 4096);
        BIO_flush(bio_b64);
        std::vector<unsigned char> result(decoded_data.begin(), decoded_data.begin() + len);

        BIO_free_all(bio_b64);
        return result;
    }

    std::string fragment_payload(const std::vector<unsigned char>& payload) {
        size_t fragment_size = 128;
        std::string fragmented_payload;

        for (size_t offset = 0; offset < payload.size(); offset += fragment_size) {
            size_t fragment_length = std::min(payload.size() - offset, fragment_size);
            fragmented_payload += "fragment" + std::to_string(offset / fragment_size + 1) + ":";
            fragmented_payload += custom_base64_encode(std::vector<unsigned char>(payload.begin() + offset, payload.begin() + offset + fragment_length));
            fragmented_payload += "\n";
        }

        return fragmented_payload;
    }

    std::string insert_dynamic_dummy_code(const std::string& fragmented_payload) {
        size_t num_fragments = count_fragments(fragmented_payload);
        std::string dynamic_dummy_code = generate_dynamic_dummy_code(num_fragments);
        std::string obfuscated_payload = fragmented_payload + dynamic_dummy_code;

        size_t dummy_code_offset = fragmented_payload.size();
        for (size_t i = 0; i < num_fragments; i++) {
            size_t fragment_offset = find_fragment(obfuscated_payload, i + 1);
            obfuscated_payload.replace(fragment_offset, 7, "dynamic_dummy_code_" + std::to_string(i + 1) + ":");
        }

        obfuscated_payload.replace(dummy_code_offset, 11, "end_dynamic_dummy_code");
        return obfuscated_payload;
    }

    std::string generate_dynamic_dummy_code(size_t num_fragments) {
        std::stringstream ss;
        ss << "int main() {" << std::endl;
        ss << "    for (int i = 0; i < " << num_fragments << "; i++) {" << std::endl;
        ss << "        std::cout << \"Dynamic dummy code for fragment " << i + 1 << "\" << std::endl;
        ss << "        std::this_thread::sleep_for(std::chrono::milliseconds(500));" << std::endl;
        ss << "    }" << std::endl;
        ss << "    return 0;" << std::endl;
        ss << "}" << std::endl;
        return ss.str();
    }

    std::string add_dynamic_behavior(const std::string& payload) {
        size_t start_index = payload.find("begin_dynamic_behavior");
        size_t end_index = payload.find("end_dynamic_behavior");

        if (start_index != std::string::npos && end_index != std::string::npos) {
            std::string dynamic_behavior = payload.substr(start_index + 14, end_index - start_index - 14);
            return payload.replace(start_index, end_index - start_index + 12, dynamic_behavior);
        } else {
            throw std::runtime_error("Dynamic behavior not found in the obfuscated payload.");
        }
    }

    size_t count_fragments(const std::string& fragmented_payload) {
        return std::count(fragmented_payload.begin(), fragmented_payload.end(), ':') / 2;
    }

    size_t find_fragment(const std::string& fragmented_payload, size_t fragment_index) {
        std::string fragment_identifier = "fragment" + std::to_string(fragment_index) + ":";
        return fragmented_payload.find(fragment_identifier) + fragment_identifier.length();
    }
};

