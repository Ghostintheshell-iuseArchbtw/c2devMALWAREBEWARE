#include <iostream>
#include <vector>
#include <openssl/aes.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <string>
#include <cstdlib>
#include <ctime>
#include <algorithm>

class PayloadObfuscatorPacker {
public:
    PayloadObfuscatorPacker(const std::vector<unsigned char>& aes_key, RSA* rsa_public_key, RSA* rsa_private_key)
        : aes_key_(aes_key), rsa_public_key_(rsa_public_key), rsa_private_key_(rsa_private_key) {
        iv_.resize(AES_BLOCK_SIZE);
        if (RAND_bytes(iv_.data(), iv_.size()) != 1) {
            throw std::runtime_error("Error generating random bytes for IV.");
        }
    }

    std::string obfuscate(const std::string& payload) {
        std::vector<unsigned char> encrypted_payload = encrypt_payload(payload);
        std::string fragmented_payload = fragment_payload(encrypted_payload);
        std::string obfuscated_payload = insert_dynamic_dummy_code(fragmented_payload);
        return add_dynamic_behavior(obfuscated_payload);
    }

    std::string deobfuscate(const std::string& obfuscated_payload) {
        std::string payload_with_metadata = remove_dynamic_dummy_code(obfuscated_payload);
        std::string decrypted_payload = decrypt_payload(payload_with_metadata);
        return decrypted_payload;
    }

private:
    std::vector<unsigned char> aes_key_;
    RSA* rsa_public_key_;
    RSA* rsa_private_key_;
    std::vector<unsigned char> iv_;

    std::vector<unsigned char> encrypt_payload(const std::string& data) {
        AES_KEY encrypt_key;
        if (AES_set_encrypt_key(aes_key_.data(), 256, &encrypt_key) != 0) {
            throw std::runtime_error("Error setting AES encryption key.");
        }

        std::vector<unsigned char> padded_data((data.size() + AES_BLOCK_SIZE - 1) / AES_BLOCK_SIZE * AES_BLOCK_SIZE);
        std::copy(data.begin(), data.end(), padded_data.begin());

        std::vector<unsigned char> encrypted_data_with_iv(AES_BLOCK_SIZE + padded_data.size());
        std::copy(iv_.begin(), iv_.end(), encrypted_data_with_iv.begin());

        AES_cbc_encrypt(padded_data.data(), encrypted_data_with_iv.data() + AES_BLOCK_SIZE,
                        padded_data.size(), &encrypt_key, iv_.data(), AES_ENCRYPT);

        std::vector<unsigned char> encrypted_aes_key(RSA_size(rsa_public_key_));
        if (RSA_public_encrypt(aes_key_.size(), aes_key_.data(), encrypted_aes_key.data(), rsa_public_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error encrypting AES key.");
        }

        std::vector<unsigned char> combined_encrypted_data;
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_aes_key.begin(), encrypted_aes_key.end());
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_data_with_iv.begin(), encrypted_data_with_iv.end());

        return custom_base64_encode(combined_encrypted_data);
    }

    std::string decrypt_payload(const std::string& encrypted_data) {
        std::vector<unsigned char> combined_encrypted_data = custom_base64_decode(encrypted_data);

        size_t aes_key_size = RSA_size(rsa_private_key_);
        std::vector<unsigned char> encrypted_aes_key(combined_encrypted_data.begin(), combined_encrypted_data.begin() + aes_key_size);
        std::vector<unsigned char> encrypted_data_with_iv(combined_encrypted_data.begin() + aes_key_size, combined_encrypted_data.end());

        std::vector<unsigned char> decrypted_aes_key(aes_key_.size());
        if (RSA_private_decrypt(encrypted_aes_key.size(), encrypted_aes_key.data(), decrypted_aes_key.data(), rsa_private_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error decrypting AES key.");
        }

        AES_KEY decrypt_key;
        if (AES_set_decrypt_key(decrypted_aes_key.data(), 256, &decrypt_key) != 0) {
            throw std::runtime_error("Error setting AES decryption key.");
        }

        std::vector<unsigned char> iv(AES_BLOCK_SIZE);
        std::copy(encrypted_data_with_iv.begin(), encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, iv.begin());
        std::vector<unsigned char> encrypted_data_part(encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, encrypted_data_with_iv.end());

        std::vector<unsigned char> decrypted_data(encrypted_data_part.size());
        AES_cbc_encrypt(encrypted_data_part.data(), decrypted_data.data(), encrypted_data_part.size(), &decrypt_key, iv.data(), AES_DECRYPT);

        return std::string(decrypted_data.begin(), decrypted_data.end());
    }

    std::string custom_base64_encode(const std::vector<unsigned char>& data) {
        BIO* bio;
        BIO* b64;
        BUF_MEM* buffer_ptr;
        std::string encoded;

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new(BIO_s_mem());
        bio = BIO_push(b64, bio);

        BIO_write(bio, data.data(), data.size());
        BIO_flush(bio);
        BIO_get_mem_ptr(bio, &buffer_ptr);

        encoded.assign(buffer_ptr->data, buffer_ptr->length);
        BIO_free_all(bio);

        return "ENC:" + encoded;
    }

    std::vector<unsigned char> custom_base64_decode(const std::string& data) {
        std::string encoded = data.substr(4); // Remove "ENC:"
        BIO* bio;
        BIO* b64;
        std::vector<unsigned char> decoded_data(encoded.size());

        b64 = BIO_new(BIO_f_base64());
        bio = BIO_new_mem_buf(encoded.data(), encoded.size());
        bio = BIO_push(b64, bio);

        int length = BIO_read(bio, decoded_data.data(), decoded_data.size());
        decoded_data.resize(length);
        BIO_free_all(bio);

        return decoded_data;
    }

    std::string fragment_payload(const std::vector<unsigned char>& payload) {
        size_t fragment_size = rand() % (150 - 50 + 1) + 50;
        std::string fragmented_payload;
        for (size_t i = 0; i < payload.size(); i += fragment_size) {
            size_t end = std::min(payload.size(), i + fragment_size);
            fragmented_payload += std::string(payload.begin() + i, payload.begin() + end) + "\n";
        }
        return fragmented_payload;
    }

    std::string insert_dynamic_dummy_code(const std::string& payload) {
        std::string dummy_code = generate_dynamic_dummy_code();
        return dummy_code + "\n" + payload + "\n" + dummy_code;
    }

    std::string remove_dynamic_dummy_code(const std::string& payload) {
        std::string result;
        size_t pos = 0;
        while ((pos = payload.find('\n', pos)) != std::string::npos) {
            size_t end = payload.find('\n', pos + 1);
            if (end == std::string::npos) end = payload.length();
            std::string line = payload.substr(pos, end - pos);
            if (!is_dynamic_dummy_code(line)) {
                result += line + "\n";
            }
            pos = end;
        }
        return result;
    }

    std::string generate_dynamic_dummy_code() {
        const std::string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()";
        std::string result(30, ' ');
        std::generate(result.begin(), result.end(), [&]() { return chars[rand() % chars.size()]; });
        return result;
    }

    bool is_dynamic_dummy_code(const std::string& line) {
        return line.length() == 30 && std::any_of(line.begin(), line.end(), [](char c) { return std::ispunct(c); });
    }

    std::string add_dynamic_behavior(const std::string& payload) {
        std::string behavior_code = generate_dynamic_behavior_code();
        return behavior_code + "\n" + payload + "\n" + behavior_code;
    }

    std::string generate_dynamic_behavior_code() {
        return R"(
#include <iostream>
#include <thread>
#include <chrono>

int main() {
    std::cout << "Dynamic behavior execution started..." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "Dynamic behavior execution completed." << std::endl;
    return 0;
}
)";
    }
};

RSA* generate_rsa_key_pair() {
    RSA* key = RSA_new();
    BIGNUM* e = BN_new();
    BN_set_word(e, RSA_F4);
    if (RSA_generate_key_ex(key, 2048, e, NULL) != 1) {
        throw std::runtime_error("Error generating RSA key pair.");
    }
    BN_free(e);
    return key;
}

int main() {
    try {
        std::vector<unsigned char> aes_key(32);
        if (RAND_bytes(aes_key.data(), aes_key.size()) != 1) {
            throw std::runtime_error("Error generating random AES key.");
        }

        RSA* rsa_key_pair = generate_rsa_key_pair();
        RSA* rsa_public_key = RSAPublicKey_dup(rsa_key_pair);
        if (!rsa_public_key) {
            throw std::runtime_error("Error duplicating RSA public key.");
        }

        PayloadObfuscatorPacker obfuscator(aes_key, rsa_public_key, rsa_key_pair);

        std::string payload = "This is a highly sensitive and secret payload!";
        std::cout << "Original Payload: " << payload << std::endl;

        std::string obfuscated_payload = obfuscator.obfuscate(payload);
        std::cout << "Obfuscated Payload: " << obfuscated_payload << std::endl;

        std::string deobfuscated_payload = obfuscator.deobfuscate(obfuscated_payload);
        std::cout << "Deobfuscated Payload: " << deobfuscated_payload << std::endl;

        RSA_free(rsa_key_pair);
        RSA_free(rsa_public_key);
    } catch (const std::exception& e) {
        std::cerr << "An error occurred: " << e.what() << std::endl;
    }

    return 0;
}
