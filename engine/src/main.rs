use std::fs::File;
use std::io::{self, Read, Write};
use std::mem;
use std::ptr;
use rand::{seq::SliceRandom, Rng};
use libc::{mmap, munmap, PROT_READ, PROT_WRITE, PROT_EXEC, MAP_PRIVATE, MAP_ANONYMOUS};
use std::path::Path;
use std::env;
use goblin::pe::{PE}; // Removed unused import

struct MetamorphicEngine {
    input_file_name: String,
    output_file_name: String,
    file_data: Vec<u8>,
}

impl MetamorphicEngine {
    // Constructor
    fn new(input_file: &str, output_file: &str) -> Self {
        Self {
            input_file_name: input_file.to_string(),
            output_file_name: output_file.to_string(),
            file_data: Vec::new(),
        }
    }

    // Read the input file into file_data
    fn read_file(&mut self) -> io::Result<()> {
        let mut file = File::open(&self.input_file_name)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;

        let pe = PE::parse(&buffer).unwrap();
        for section in pe.sections {
            // Get the section data
            let section_data = &buffer[section.pointer_to_raw_data as usize..(section.pointer_to_raw_data + section.size_of_raw_data) as usize];
            self.file_data.extend(section_data);
        }

        Ok(())
    }

    // Write the obfuscated data to the output file
    fn write_file(&self) -> io::Result<()> {
        let mut file = File::create(&self.output_file_name)?;
        file.write_all(&self.file_data)?;
        Ok(())
    }

    // Perform all obfuscation techniques
    fn perform_obfuscation(&mut self) {
        self.reorder_code();
        self.substitute_instructions();
        self.insert_garbage_code();
        self.insert_anti_debugging();
        self.generate_dynamic_code();
        self.apply_code_transformation();
        self.encrypt_code();
        self.add_stack_smashing_protection();
        self.include_anti_reverse_engineering_techniques();
        self.insert_nop_sleds();
        self.insert_rop_chains();
        self.duplicate_stack_frames();
    }

    // Reorder code instructions
    fn reorder_code(&mut self) {
        let mut rng = rand::thread_rng();
        self.file_data.shuffle(&mut rng);
    }

    // Substitute instructions with equivalent but less obvious ones
    fn substitute_instructions(&mut self) {
        for byte in &mut self.file_data {
            match byte {
                0x90 => *byte = 0xC3, // NOP -> RET
                0xE9 => *byte = 0xEB, // JMP -> Short JMP
                0xC3 => *byte = 0x90, // RET -> NOP
                _ => {}
            }
        }
    }

    // Insert garbage code
    fn insert_garbage_code(&mut self) {
        let mut rng = rand::thread_rng();
        for i in (0..self.file_data.len()).step_by(100) {
            if i + 20 < self.file_data.len() {
                for j in i..i + 20 {
                    self.file_data[j] = rng.gen_range(0..=255);
                }
            }
        }
    }

    // Insert anti-debugging code
    fn insert_anti_debugging(&mut self) {
        let anti_debug_code: Vec<u8> = vec![
            0xB8, 0x00, 0x00, 0x00, 0x00, // MOV EAX, 0
            0x0F, 0x1F, 0x40, 0x00,       // NOP (align for next instruction)
            0x50,                           // PUSH EAX
            0x6A, 0x00,                     // PUSH 0 (Debug Active check)
            0x6A, 0x00,                     // PUSH 0
            0xFF, 0x15, 0x00, 0x00, 0x00, 0x00, // CALL [Address of a debug function]
            0x58                            // POP EAX
        ];
        self.file_data.extend(anti_debug_code);
    }

    // Generate dynamic code
    fn generate_dynamic_code(&self) {
        let dynamic_code: Vec<u8> = vec![
            0x48, 0x89, 0xE5,              // MOV RBP, RSP
            0x48, 0x83, 0xEC, 0x20,        // SUB RSP, 0x20
            0xB8, 0x01, 0x00, 0x00, 0x00, // MOV EAX, 1
            0xC9,                          // LEAVE
            0xC3                           // RET
        ];
        self.execute_dynamic_code(&dynamic_code);
    }

    // Execute dynamically generated code
    fn execute_dynamic_code(&self, code: &[u8]) {
        let code_size = code.len();
        let mem = unsafe {
            mmap(
                ptr::null_mut(),
                code_size,
                PROT_READ | PROT_WRITE | PROT_EXEC,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0,
            )
        };

        if mem == libc::MAP_FAILED {
            eprintln!("mmap failed");
            std::process::exit(1);
        }

        unsafe {
            ptr::copy_nonoverlapping(code.as_ptr(), mem as *mut u8, code_size);
            let func: fn() = mem::transmute(mem);
            func(); // Execute the code
            munmap(mem, code_size);
        }
    }

    // Apply code transformations (e.g., encryption)
    fn apply_code_transformation(&mut self) {
        for i in 0..self.file_data.len() {
            self.file_data[i] ^= (0xAA + (i % 256)) as u8; // More complex XOR encryption
        }
    }

    // Encrypt the code
    fn encrypt_code(&mut self) {
        let key: u8 = 0xAA;
        for byte in &mut self.file_data {
            *byte ^= key; // Simple XOR encryption
        }
    }

    // Decrypt the code (for debugging purposes, if needed)
    fn decrypt_code(&mut self) {
        let key: u8 = 0xAA;
        for byte in &mut self.file_data {
            *byte ^= key; // Simple XOR decryption
        }
    }

    // Add stack smashing protection
    fn add_stack_smashing_protection(&mut self) {
        let stack_guard_code: Vec<u8> = vec![
            0x48, 0x83, 0xEC, 0x28,  // SUB RSP, 0x28
            0x48, 0x8D, 0x3D, 0x00, 0x00, 0x00, 0x00, // LEA RDI, [RIP+0x00]
            0x48, 0x89, 0xF7,  // MOV RDI, RSI
            0x48, 0x83, 0xC4, 0x28,  // ADD RSP, 0x28
            0xC3                  // RET
        ];
        self.file_data.extend(stack_guard_code);
    }

    // Include anti-reverse engineering techniques
    fn include_anti_reverse_engineering_techniques(&mut self) {
        // Implement various techniques like code virtualization, obfuscation libraries, etc.
        let anti_reverse_code: Vec<u8> = vec![
            0x90, 0x90, 0x90, 0x90, // NOP sled
            0xE8, 0x00, 0x00, 0x00, 0x00, // CALL (dummy function)
            0x90, 0x90, 0x90, 0x90  // NOP sled
        ];
        self.file_data.extend(anti_reverse_code);
    }

    // Insert NOP sleds
    fn insert_nop_sleds(&mut self) {
        let mut offset = 0;
        while offset < self.file_data.len() {
            self.file_data.splice(offset..offset, vec![0x90; 10]); // Insert 10 NOPs
            offset += 20; // Skip ahead to insert more NOP sleds
        }
    }

    // Insert ROP chains
    fn insert_rop_chains(&mut self) {
        let rop_chain: Vec<u8> = vec![
            0x58, // POP RAX
            0x59, // POP RCX
            0x5A, // POP RDX
            0x5B, // POP RBX
            0x5C, // POP RSP
            0x5D, // POP RBP
            0x5E, // POP RSI
            0x5F, // POP RDI
        ];
        self.file_data.extend(rop_chain);
    }

    // Duplicate stack frames
    fn duplicate_stack_frames(&mut self) {
        let stack_dup_code: Vec<u8> = vec![
            0x50, // PUSH RAX
            0x51, // PUSH RCX
            0x52, // PUSH RDX
            0x53, // PUSH RBX
            0x54, // PUSH RSP
            0x55, // PUSH RBP
            0x56, // PUSH RSI
            0x57, // PUSH RDI 
            0xC3  // RET
        ];
        self.file_data.extend(stack_dup_code);
    }
}

fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        println!("Usage: {} <input_file>", args[0]);
        std::process::exit(1);
    }

    let input_file = &args[1];
    let output_file = format!("~/Desktop/{}", Path::new(input_file).file_name().unwrap().to_str().unwrap());

    let mut engine = MetamorphicEngine::new(input_file, &output_file);
    engine.read_file()?;
    engine.perform_obfuscation();
    engine.write_file()?;
    Ok(())
}
