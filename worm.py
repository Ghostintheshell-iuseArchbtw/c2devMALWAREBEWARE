import os
import sys
import socket
import threading
import base64
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Util.Padding import pad, unpad
from typing import Tuple, List

class Worm:
    def __init__(self, aes_key: bytes, rsa_key_pair):
        self.aes_key = aes_key
        self.rsa_public_key, self.rsa_private_key = rsa_key_pair
        self.cipher_aes = AES.new(self.aes_key, AES.MODE_CBC)
        self.iv = self.cipher_aes.iv
        self.cipher_rsa = PKCS1_OAEP.new(self.rsa_public_key)
        self.cipher_rsa_private = PKCS1_OAEP.new(self.rsa_private_key)
        self.server_address = ('localhost', 9999)  # Example address; adjust as needed

    def encrypt_payload(self, data: bytes) -> bytes:
        cipher = AES.new(self.aes_key, AES.MODE_CBC, self.iv)
        padded_data = pad(data, AES.block_size)
        encrypted_data = cipher.encrypt(padded_data)
        encrypted_data_with_iv = self.iv + encrypted_data
        encrypted_aes_key = self.cipher_rsa.encrypt(self.aes_key)
        combined_encrypted_data = encrypted_aes_key + encrypted_data_with_iv
        return combined_encrypted_data

    def decrypt_payload(self, encrypted_data: bytes) -> bytes:
        encrypted_aes_key = encrypted_data[:256]
        encrypted_data_with_iv = encrypted_data[256:]
        decrypted_aes_key = self.cipher_rsa_private.decrypt(encrypted_aes_key)
        cipher = AES.new(decrypted_aes_key, AES.MODE_CBC, encrypted_data_with_iv[:AES.block_size])
        encrypted_data = encrypted_data_with_iv[AES.block_size:]
        decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size)
        return decrypted_data

    def communicate(self, message: str) -> None:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect(self.server_address)
                encrypted_message = self.encrypt_payload(message.encode())
                s.sendall(encrypted_message)
                print("Message sent successfully.")
        except Exception as e:
            print(f"Communication error: {e}")

    def listen(self) -> None:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind(self.server_address)
            s.listen()
            print(f"Listening on {self.server_address}")
            while True:
                conn, addr = s.accept()
                with conn:
                    print(f"Connected by {addr}")
                    encrypted_message = conn.recv(1024)
                    if encrypted_message:
                        decrypted_message = self.decrypt_payload(encrypted_message).decode()
                        print(f"Received message: {decrypted_message}")

    def run(self):
        listener_thread = threading.Thread(target=self.listen, daemon=True)
        listener_thread.start()

        # For demonstration, send a test message
        self.communicate("Test message from worm.")

def generate_rsa_key_pair() -> Tuple:
    key = RSA.generate(2048)
    private_key = key
    public_key = key.publickey()
    return (public_key, private_key)

def main():
    try:
        aes_key = os.urandom(32)
        rsa_key_pair = generate_rsa_key_pair()
        worm = Worm(aes_key, rsa_key_pair)

        worm.run()
        
    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
