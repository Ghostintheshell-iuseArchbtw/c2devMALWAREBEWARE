use std::fs::File;
use std::io::{self, Read, Write, BufRead, BufReader};
use std::process;

#[derive(Debug)]
enum Instruction {
    Push(u64),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Mov(usize, usize), // Destination, Source
    Jmp(usize),
    Jz(usize),
    Jnz(usize),
    Cmp(u64, u64),
    Hlt,
}

struct VM {
    memory: Vec<u64>,
    stack: Vec<u64>,
    ip: usize, // Instruction pointer
}

impl VM {
    fn new() -> Self {
        Self {
            memory: Vec::new(),
            stack: Vec::new(),
            ip: 0,
        }
    }

    fn load_program(&mut self, program: &[u64]) {
        self.memory = program.to_vec();
    }

    fn execute(&mut self) {
        while self.ip < self.memory.len() {
            let instr = self.decode_instruction(self.memory[self.ip]);

            match instr {
                Ok(instruction) => self.execute_instruction(instruction),
                Err(e) => self.handle_execution_error(&e),
            }
            self.ip += 1;
        }
    }

    fn decode_instruction(&self, byte: u64) -> Result<Instruction, String> {
        match byte {
            0x00 => Ok(Instruction::Push(self.memory[self.ip + 1])),
            0x01 => Ok(Instruction::Pop),
            0x02 => Ok(Instruction::Add),
            0x03 => Ok(Instruction::Sub),
            0x04 => Ok(Instruction::Mul),
            0x05 => Ok(Instruction::Div),
            0x06 => Ok(Instruction::Mov(
                self.memory[self.ip + 1] as usize,
                self.memory[self.ip + 2] as usize,
            )),
            0x07 => Ok(Instruction::Jmp(self.memory[self.ip + 1] as usize)),
            0x08 => Ok(Instruction::Jz(self.memory[self.ip + 1] as usize)),
            0x09 => Ok(Instruction::Jnz(self.memory[self.ip + 1] as usize)),
            0x0A => Ok(Instruction::Hlt),
            0x0B => Ok(Instruction::Cmp(
                self.memory[self.ip + 1],
                self.memory[self.ip + 2],
            )),
            _ => Err(format!("Unknown instruction: {}", byte)),
        }
    }

    fn execute_instruction(&mut self, instr: Instruction) {
        match instr {
            Instruction::Push(value) => {
                self.stack.push(value);
            }
            Instruction::Pop => {
                self.stack.pop();
            }
            Instruction::Add => self.arithmetic_op(|a, b| a.wrapping_add(b)),
            Instruction::Sub => self.arithmetic_op(|a, b| a.wrapping_sub(b)),
            Instruction::Mul => self.arithmetic_op(|a, b| a.wrapping_mul(b)),
            Instruction::Div => self.divide(),
            Instruction::Mov(dst, src) => {
                if src < self.stack.len() {
                    self.stack[dst] = self.stack[src];
                }
            }
            Instruction::Jmp(addr) => {
                self.ip = addr;
                return; // Skip ip increment
            }
            Instruction::Jz(addr) => {
                if let Some(&top) = self.stack.last() {
                    if top == 0 {
                        self.ip = addr;
                    }
                }
            }
            Instruction::Jnz(addr) => {
                if let Some(&top) = self.stack.last() {
                    if top != 0 {
                        self.ip = addr;
                    }
                }
            }
            Instruction::Hlt => process::exit(0),
            Instruction::Cmp(a, b) => {
                if a == b {
                    self.stack.push(0); // Indicate zero
                } else {
                    self.stack.push(1); // Indicate non-zero
                }
            }
        }
    }

    fn arithmetic_op<F>(&mut self, op: F)
    where
        F: Fn(u64, u64) -> u64,
    {
        if self.stack.len() < 2 {
            self.handle_execution_error("Not enough operands on stack");
        }
        let b = self.stack.pop().expect("Stack is empty");
        let a = self.stack.pop().expect("Stack is empty");
        self.stack.push(op(a, b));
    }

    fn divide(&mut self) {
        if self.stack.len() < 2 {
            self.handle_execution_error("Not enough operands on stack for DIV");
        }
        let b = self.stack.pop().expect("Stack is empty");
        let a = self.stack.pop().expect("Stack is empty");
        if b == 0 {
            self.handle_execution_error("Division by zero");
        }
        self.stack.push(a.wrapping_div(b));
    }

    fn handle_execution_error(&self, msg: &str) {
        eprintln!("Execution error: {}", msg);
        process::exit(1);
    }
}

fn assemble_line(line: &str) -> Result<u64, String> {
    let parts: Vec<&str> = line.split_whitespace().collect();
    match parts[0] {
        "PUSH" => {
            if let Some(value) = parts.get(1) {
                value.parse::<u64>().map_err(|_| "Invalid value".to_string()).map(|v| 0x00 | (v << 8))
            } else {
                Err("PUSH instruction requires a value".to_string())
            }
        }
        "POP" => Ok(0x01),
        "ADD" => Ok(0x02),
        "SUB" => Ok(0x03),
        "MUL" => Ok(0x04),
        "DIV" => Ok(0x05),
        "MOV" => {
            if let (Some(dst), Some(src)) = (parts.get(1), parts.get(2)) {
                let dst_index: usize = dst.parse().map_err(|_| "Invalid destination index".to_string())?;
                let src_index: usize = src.parse().map_err(|_| "Invalid source index".to_string())?;
                Ok(0x06 | (dst_index as u64) << 8 | (src_index as u64) << 16)
            } else {
                Err("MOV instruction requires two operands".to_string())
            }
        }
        "JMP" => {
            if let Some(addr) = parts.get(1) {
                addr.parse::<usize>().map_err(|_| "Invalid address".to_string()).map(|v| 0x07 | (v as u64) << 8)
            } else {
                Err("JMP instruction requires an address".to_string())
            }
        }
        "JZ" => {
            if let Some(addr) = parts.get(1) {
                addr.parse::<usize>().map_err(|_| "Invalid address".to_string()).map(|v| 0x08 | (v as u64) << 8)
            } else {
                Err("JZ instruction requires an address".to_string())
            }
        }
        "JNZ" => {
            if let Some(addr) = parts.get(1) {
                addr.parse::<usize>().map_err(|_| "Invalid address".to_string()).map(|v| 0x09 | (v as u64) << 8)
            } else {
                Err("JNZ instruction requires an address".to_string())
            }
        }
        "CMP" => {
            if let (Some(a), Some(b)) = (parts.get(1), parts.get(2)) {
                let a_val: u64 = a.parse().map_err(|_| "Invalid value".to_string())?;
                let b_val: u64 = b.parse().map_err(|_| "Invalid value".to_string())?;
                Ok(0x0B | (a_val << 8) | (b_val << 16))
            } else {
                Err("CMP instruction requires two values".to_string())
            }
        }
        "HLT" => Ok(0x0A),
        _ => Err(format!("Unknown instruction: {}", parts[0])),
    }
}

fn assemble_program(filename: &str) -> Result<Vec<u64>, String> {
    let file = File::open(filename).map_err(|e| e.to_string())?;
    let reader = BufReader::new(file);
    let mut program = Vec::new();

    for line in reader.lines() {
        let line = line.map_err(|e| e.to_string())?;
        if line.trim().is_empty() {
            continue; // Skip empty lines
        }
        let instruction = assemble_line(&line)?;
        program.push(instruction);
    }

    Ok(program)
}

fn main() -> io::Result<()> {
    // Load program from file
    let filename = "program.asm"; // Change to your assembly source file
    let program = assemble_program(filename).map_err(|e| {
        eprintln!("Assembly error: {}", e);
        e
    })?;

    // Create and run the VM
    let mut vm = VM::new();
    vm.load_program(&program);
    vm.execute();

    Ok(())
}

