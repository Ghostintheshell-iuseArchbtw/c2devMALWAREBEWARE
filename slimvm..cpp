#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/ptrace.h>
#include <ctime>
#include <random>
#include <openssl/aes.h>

namespace myobfuscationvm {

enum class Instruction {
    PUSH,
    POP,
    ADD,
    SUB,
    MUL,
    DIV,
    XOR,
    MOV,
    JMP,
    JZ,
    HLT,
    LOAD,
    STORE,
    CALL,
    RET,
    PTRACECHK,
    ENCRYPT,
    DECRYPT,
    JMPRND,
    MOVRND,
    ADDRND,
    SUBRND,
    MULRND,
    DIVRND,
    XORRND,
    ENCRYPTRND,
    DECRYPTRND
};

class VM {
private:
    std::vector<uint8_t> memory;
    std::vector<uint8_t> stack;
    uint8_t ip; // Instruction pointer
    uint8_t sp; // Stack pointer

public:
    VM(const std::vector<uint8_t>& data) : memory(data), ip(0), sp(0) {}

    void execute() {
        while (ip < memory.size()) {
            Instruction instr = static_cast<Instruction>(memory[ip]);
            switch (instr) {
                case Instruction::PUSH:
                    stack.push_back(memory[++ip]);
                    sp++;
                    break;
                case Instruction::POP:
                    if (stack.empty()) handleExecutionError("Stack underflow");
                    stack.pop_back();
                    sp--;
                    break;
                case Instruction::ADD: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for ADD");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back(a + b); sp++;
                    break;
                }
                case Instruction::SUB: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for SUB");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back(a - b); sp++;
                    break;
                }
                case Instruction::MUL: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for MUL");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back(a * b); sp++;
                    break;
                }
                case Instruction::DIV: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for DIV");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    if (b == 0) handleExecutionError("Division by zero");
                    stack.push_back(a / b); sp++;
                    break;
                }
                case Instruction::XOR: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for XOR");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back(a ^ b); sp++;
                    break;
                }
                case Instruction::MOV: {
                    uint8_t src = memory[++ip];
                    uint8_t dst = memory[++ip];
                    if (dst >= memory.size() || src >= memory.size())
                        handleExecutionError("Invalid memory access");
                    memory[dst] = memory[src];
                    break;
                }
                case Instruction::JMP:
                    ip = memory[++ip];
                    break;
                case Instruction::JZ: {
                    uint8_t cond = stack.back(); stack.pop_back(); sp--;
                    if (cond == 0) {
                        ip = memory[++ip];
                    } else {
                        ip++;
                    }
                    break;
                }
                case Instruction::HLT:
                    return;
                case Instruction::LOAD: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for LOAD");
                    stack.push_back(memory[addr]); sp++;
                    break;
                }
                case Instruction::STORE: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for STORE");
                    memory[addr] = stack.back(); stack.pop_back(); sp--;
                    break;
                }
                case Instruction::CALL: {
                    uint8_t addr = memory[++ip];
                    stack.push_back(ip + 1); sp++;
                    ip = addr;
                    break;
                }
                case Instruction::RET:
                    if (stack.empty()) handleExecutionError("Stack underflow on RET");
                    ip = stack.back(); stack.pop_back(); sp--;
                    break;
                case Instruction::PTRACECHK:
                    if (ptrace(PTRACE_TRACEME, 0, NULL, 0) == -1) {
                        handleExecutionError("Debugger detected");
                    }
                    break;
                case Instruction::ENCRYPT: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for ENCRYPT");
                    uint8_t value = memory[addr];
                    uint8_t key = 0xAA; // Example static key
                    stack.push_back(value ^ key); sp++;
                    break;
                }
                case Instruction::DECRYPT: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for DECRYPT");
                    uint8_t value = memory[addr];
                    uint8_t key = 0xAA; // Example static key
                    stack.push_back(value ^ key); sp++;
                    break;
                }
                case Instruction::JMPRND: {
                    int8_t offset = rand() % 256 - 128; // Random offset between -128 to +127
                    ip = (ip + offset) % memory.size();
                    break;
                }
                case Instruction::MOVRND: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for MOVRND");
                    memory[addr] = rand() % 256; // Random value
                    break;
                }
                case Instruction::ADDRND: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for ADDRND");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back((a + b + rand() % 256) % 256); // Add random noise and wrap around
                    sp++;
                    break;
                }
                case Instruction::SUBRND: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for SUBRND");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back((a - b + rand() % 256) % 256); // Subtract with random noise and wrap around
                    sp++;
                    break;
                }
                case Instruction::MULRND: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for MULRND");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back((a * b + rand() % 256) % 256); // Multiply with random noise and wrap around
                    sp++;
                    break;
                }
                case Instruction::DIVRND: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for DIVRND");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    if (b == 0) handleExecutionError("Division by zero");
                    stack.push_back((a / b + rand() % 256) % 256); // Divide with random noise and wrap around
                    sp++;
                    break;
                }
                case Instruction::XORRND: {
                    if (sp < 2) handleExecutionError("Not enough operands on stack for XORRND");
                    uint8_t a = stack.back(); stack.pop_back(); sp--;
                    uint8_t b = stack.back(); stack.pop_back(); sp--;
                    stack.push_back((a ^ b + rand() % 256) % 256); // XOR with random noise and wrap around
                    sp++;
                    break;
                }
                case Instruction::ENCRYPTRND: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for ENCRYPTRND");
                    uint8_t value = memory[addr];
                    uint8_t key = rand() % 256; // Random key
                    stack.push_back(value ^ key); sp++;
                    break;
                }
                case Instruction::DECRYPTRND: {
                    uint8_t addr = memory[++ip];
                    if (addr >= memory.size()) handleExecutionError("Invalid memory address for DECRYPTRND");
                    uint8_t value = memory[addr];
                    uint8_t key = rand() % 256; // Random key
                    stack.push_back(value ^ key); sp++;
                    break;
                }
                default:
                    handleExecutionError("Unknown instruction");
            }
            ip++;
        }
    }

private:
    void handleExecutionError(const std::string& message) {
        std::cerr << "Execution Error: " << message << std::endl;
        exit(EXIT_FAILURE);
    }
};

class ObfuscationEngine {
private:
    std::string inputFilePath;
    std::string outputFilePath;
    std::vector<uint8_t> fileData;

    void readFile() {
        std::ifstream inputFile(inputFilePath, std::ios::binary);
        if (!inputFile) {
            handleFileError("Could not open input file for reading");
        }
        fileData.assign((std::istreambuf_iterator<char>(inputFile)),
                        (std::istreambuf_iterator<char>()));
    }

    void writeFile(const std::vector<uint8_t>& data) {
        std::ofstream outputFile(outputFilePath, std::ios::binary);
        if (!outputFile) {
            handleFileError("Could not open output file for writing");
        }
        outputFile.write(reinterpret_cast<const char*>(data.data()), data.size());
    }

    void encryptData(std::vector<uint8_t>& data) {
        AES_KEY encryptKey;
        unsigned char key[16] = "s3cr3t_k3y_1234"; // Example key, should be securely generated
        unsigned char iv[AES_BLOCK_SIZE] = {0}; // Initialization vector
        int num = 0; // For AES CFB mode

        if (AES_set_encrypt_key(key, 128, &encryptKey) < 0) {
            handleEncryptionError("Failed to set AES encryption key");
        }

        std::vector<uint8_t> encrypted(data.size());
        AES_cfb128_encrypt(data.data(), encrypted.data(), data.size(), &encryptKey, iv, &num, AES_ENCRYPT);
        data.swap(encrypted);
    }

    void decryptData(std::vector<uint8_t>& data) {
        AES_KEY decryptKey;
        unsigned char key[16] = "s3cr3t_k3y_1234"; // Example key, should be securely generated
        unsigned char iv[AES_BLOCK_SIZE] = {0}; // Initialization vector
        int num = 0; // For AES CFB mode

        if (AES_set_decrypt_key(key, 128, &decryptKey) < 0) {
            handleEncryptionError("Failed to set AES decryption key");
        }

        std::vector<uint8_t> decrypted(data.size());
        AES_cfb128_encrypt(data.data(), decrypted.data(), data.size(), &decryptKey, iv, &num, AES_DECRYPT);
        data.swap(decrypted);
    }

    void handleFileError(const std::string& errorMsg) {
        std::cerr << "File Error: " << errorMsg << std::endl;
        exit(EXIT_FAILURE);
    }

    void handleEncryptionError(const std::string& errorMsg) {
        std::cerr << "Encryption Error: " << errorMsg << std::endl;
        exit(EXIT_FAILURE);
    }

public:
    ObfuscationEngine(const std::string& input, const std::string& output)
        : inputFilePath(input), outputFilePath(output) {}

    void execute() {
        readFile();
        VM vm(fileData);
        vm.execute(); // Execute the VM to transform the data
        encryptData(fileData); // Encrypt the transformed data
        writeFile(fileData);
    }
};

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <input_file> <output_file>" << std::endl;
        return EXIT_FAILURE;
    }

    myobfuscationvm::ObfuscationEngine engine(argv[1], argv[2]);
    engine.execute();
    return EXIT_SUCCESS;
}
