from rich.console import Console
from rich.prompt import Prompt
from rich.progress import Progress, BarColumn, TextColumn
from rich.panel import Panel
from rich.table import Table
from rich.text import Text
import time
import random
import string
import os

# Define magic numbers as constants
NOP = 0x90
RET = 0xC3
JMP = 0xE9
MOV_EAX = 0xB8
MOV_EBX = 0xB9
STACK_CANARY = b'\xDE\xAD\xBE\xEF'
VM_CODE = b'\xDE\xAD\xBE\xEF'
NOP_SLED = b'\x90' * 64
ROP_CHAIN = b'\x5F\x5E\x5D\xC3'

class MetamorphicEngine:
    def __init__(self, input_file, output_file):
        self.input_file = input_file
        self.output_file = output_file
        self.console = Console()
        self.file_data = bytearray()
        self.options = {
            "Reorder Code": False,
            "Substitute Instructions": False,
            "Insert Garbage Code": False,
            "Insert Anti-Debugging": False,
            "Generate Dynamic Code": False,
            "Apply Code Transformation": False,
            "Encrypt Code": False,
            "Add Stack Smashing Protection": False,
            "Include Anti-Reverse Engineering": False,
            "Insert NOP Sleds": False,
            "Insert ROP Chains": False,
            "Duplicate Stack Frames": False,
            "Include VM Code": False,
        }

    def display_header(self):
        self.console.print(Panel("Metamorphic Engine", style="bold blue", title="[bold white]Welcome[/bold white]"))

    def prompt_options(self):
        self.display_header()
        self.console.print("Select the options to enable for obfuscation. Type 'exit' to finish.")
        while True:
            self.console.print("\nCurrent Options:")
            for idx, (option, enabled) in enumerate(self.options.items(), 1):
                status = "[bold green]Enabled[/bold green]" if enabled else "[bold red]Disabled[/bold red]"
                self.console.print(f"{idx}. {option} - {status}")

            choice = Prompt.ask("Enter option number to toggle (or 'done' to finish)")
            if choice.lower() == 'done':
                break
            elif choice.isdigit() and 1 <= int(choice) <= len(self.options):
                opt = list(self.options.keys())[int(choice) - 1]
                self.options[opt] = not self.options[opt]
                self.console.print(f"[bold cyan]Toggled {opt}[/bold cyan]")
            else:
                self.console.print("[bold red]Invalid choice. Please try again.[/bold red]")

    def display_options(self):
        self.console.print(Panel("Options and Settings", style="bold blue"))
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Option", style="dim")
        table.add_column("Enabled")
        
        for option, enabled in self.options.items():
            table.add_row(option, "Yes" if enabled else "No")
        
        self.console.print(table)

    def display_best_practices(self):
        self.console.print(Panel("Best Practices for Obfuscation", style="bold yellow"))
        self.console.print(
            "[bold green]1. Reordering code[/bold green] - Helps to break patterns and make reverse engineering harder.\n"
            "[bold green]2. Substituting instructions[/bold green] - Replaces instructions with functionally equivalent alternatives.\n"
            "[bold green]3. Inserting garbage code[/bold green] - Adds non-functional code to confuse disassemblers.\n"
            "[bold green]4. Anti-debugging techniques[/bold green] - Prevents debugging and reverse engineering.\n"
            "[bold green]5. Dynamic code generation[/bold green] - Creates and executes code at runtime.\n"
            "[bold green]6. Code transformations[/bold green] - Applies transformations to the code for additional obfuscation.\n"
            "[bold green]7. Encryption[/bold green] - Encrypts code to prevent static analysis.\n"
            "[bold green]8. Stack smashing protection[/bold green] - Adds stack canaries to prevent stack overflow attacks.\n"
            "[bold green]9. Anti-reverse engineering techniques[/bold green] - Techniques to thwart reverse engineering efforts.\n"
            "[bold green]10. NOP sleds[/bold green] - Adds NOP instructions to make certain code areas more resilient.\n"
            "[bold green]11. ROP chains[/bold green] - Adds Return-Oriented Programming chains to obfuscate execution flow.\n"
            "[bold green]12. Duplicate stack frames[/bold green] - Duplicates stack frames to confuse stack-based attacks.\n"
            "[bold green]13. Virtual machine code[/bold green] - Includes VM code to add an additional layer of obfuscation."
        )

    def read_file(self):
        self.console.print(f"[bold cyan]Reading file:[/bold cyan] {self.input_file}")
        try:
            with open(self.input_file, 'rb') as f:
                self.file_data = bytearray(f.read())
        except IOError as e:
            self.console.print(f"[bold red]Error reading file:[/bold red] {e}")
            exit(1)

    def write_file(self):
        self.console.print(f"[bold cyan]Writing file:[/bold cyan] {self.output_file}")
        try:
            with open(self.output_file, 'wb') as f:
                f.write(self.file_data)
        except IOError as e:
            self.console.print(f"[bold red]Error writing file:[/bold red] {e}")
            exit(1)

    def perform_obfuscation(self):
        self.console.print(Panel("Starting obfuscation process...", style="bold blue"))
        with Progress(
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            console=self.console,
        ) as progress:
            task = progress.add_task("[cyan]Obfuscating...", total=100)
            while not progress.finished:
                time.sleep(0.1)
                progress.update(task, advance=random.uniform(1, 5))

            # Perform actions based on options
            if self.options["Reorder Code"]:
                self.reorder_code()
            if self.options["Substitute Instructions"]:
                self.substitute_instructions()
            if self.options["Insert Garbage Code"]:
                self.insert_garbage_code()
            if self.options["Insert Anti-Debugging"]:
                self.insert_anti_debugging()
            if self.options["Generate Dynamic Code"]:
                self.generate_dynamic_code()
            if self.options["Apply Code Transformation"]:
                self.apply_code_transformation()
            if self.options["Encrypt Code"]:
                self.encrypt_code()
            if self.options["Add Stack Smashing Protection"]:
                self.add_stack_smashing_protection()
            if self.options["Include Anti-Reverse Engineering"]:
                self.include_anti_reverse_engineering_techniques()
            if self.options["Insert NOP Sleds"]:
                self.insert_nop_sleds()
            if self.options["Insert ROP Chains"]:
                self.insert_rop_chains()
            if self.options["Duplicate Stack Frames"]:
                self.duplicate_stack_frames()
            if self.options["Include VM Code"]:
                self.include_vm_code()

        self.console.print(Panel("Obfuscation completed.", style="bold green"))

    def reorder_code(self):
        self.console.print("[bold yellow]Reordering code...[/bold yellow]")
        random.shuffle(self.file_data)

    def substitute_instructions(self):
        self.console.print("[bold yellow]Substituting instructions...[/bold yellow]")
        substitutions = {NOP: RET, JMP: RET, RET: NOP, MOV_EAX: MOV_EBX}
        self.file_data = bytearray(substitutions.get(byte, byte) for byte in self.file_data)

    def insert_garbage_code(self):
        self.console.print("[bold yellow]Inserting garbage code...[/bold yellow]")
        for _ in range(10):
            pos = random.randint(0, len(self.file_data) - 10)
            garbage = bytes(random.choices(string.ascii_letters.encode() + b'\x00', k=10))
            self.file_data[pos:pos] = garbage

    def insert_anti_debugging(self):
        self.console.print("[bold yellow]Inserting anti-debugging techniques...[/bold yellow]")
        anti_debug_code = b'\xCC\xF1'
        self.file_data.extend(anti_debug_code)

    def generate_dynamic_code(self):
        self.console.print("[bold yellow]Generating dynamic code...[/bold yellow]")
        dynamic_code = b'\xB8\x01\x00\x00\x00\xC3'
        self.file_data.extend(dynamic_code)

    def apply_code_transformation(self):
        self.console.print("[bold yellow]Applying code transformations...[/bold yellow]")
        transformed_code = bytearray()
        for byte in self.file_data:
            transformed_code.append(byte ^ 0xAA)
        self.file_data = transformed_code

    def encrypt_code(self):
        self.console.print("[bold yellow]Encrypting code...[/bold yellow]")
        key = 0xAA
        self.file_data = bytearray(byte ^ key for byte in self.file_data)

    def add_stack_smashing_protection(self):
        self.console.print("[bold yellow]Adding stack smashing protection...[/bold yellow]")
        self.file_data.extend(STACK_CANARY)

    def include_anti_reverse_engineering_techniques(self):
        self.console.print("[bold yellow]Including anti-reverse engineering techniques...[/bold yellow]")
        anti_reverse_code = b'\xF9\xB9'
        self.file_data.extend(anti_reverse_code)

    def insert_nop_sleds(self):
        self.console.print("[bold yellow]Inserting NOP sleds...[/bold yellow]")
        self.file_data = NOP_SLED + self.file_data + NOP_SLED

    def insert_rop_chains(self):
        self.console.print("[bold yellow]Inserting ROP chains...[/bold yellow]")
        self.file_data.extend(ROP_CHAIN)

    def duplicate_stack_frames(self):
        self.console.print("[bold yellow]Duplicating stack frames...[/bold yellow]")
        self.file_data = self.file_data * 2

    def include_vm_code(self):
        self.console.print("[bold yellow]Including VM code...[/bold yellow]")
        self.file_data.extend(VM_CODE)

if __name__ == "__main__":
    input_file = Prompt.ask("Enter input file path")
    output_file = Prompt.ask("Enter output file path")

    engine = MetamorphicEngine(input_file, output_file)
    
    engine.read_file()
    engine.display_options()
    engine.prompt_options()
    engine.display_best_practices()
    engine.perform_obfuscation()
    engine.write_file()

    engine.console.print(f"[bold green]Obfuscation process completed. Output file: {output_file}[/bold green]")

