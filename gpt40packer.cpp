#include <iostream>
#include <vector>
#include <openssl/aes.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <string>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <memory>

class PayloadObfuscatorPacker {
public:
    PayloadObfuscatorPacker(const std::vector<unsigned char>& aes_key, RSA* rsa_public_key, RSA* rsa_private_key)
        : aes_key_(aes_key), rsa_public_key_(rsa_public_key), rsa_private_key_(rsa_private_key) {
        if (!RAND_bytes(iv_.data(), iv_.size())) {
            throw std::runtime_error("Error generating random bytes for IV: " + get_openssl_error());
        }
    }

    std::string obfuscate(const std::string& payload) {
        auto encrypted_payload = encrypt_payload(payload);
        auto fragmented_payload = fragment_payload(encrypted_payload);
        auto obfuscated_payload = insert_dynamic_dummy_code(fragmented_payload);
        return add_dynamic_behavior(obfuscated_payload);
    }

    std::string deobfuscate(const std::string& obfuscated_payload) {
        auto payload_with_metadata = remove_dynamic_dummy_code(obfuscated_payload);
        return decrypt_payload(payload_with_metadata);
    }

private:
    std::vector<unsigned char> aes_key_;
    RSA* rsa_public_key_;
    RSA* rsa_private_key_;
    std::vector<unsigned char> iv_{AES_BLOCK_SIZE};

    std::vector<unsigned char> encrypt_payload(const std::string& data) {
        AES_KEY encrypt_key;
        if (AES_set_encrypt_key(aes_key_.data(), 256, &encrypt_key) != 0) {
            throw std::runtime_error("Error setting AES encryption key: " + get_openssl_error());
        }

        // Apply PKCS7 padding
        std::vector<unsigned char> padded_data = apply_pkcs7_padding(data);
        std::vector<unsigned char> encrypted_data_with_iv(AES_BLOCK_SIZE + padded_data.size());

        // Copy IV to the beginning of the encrypted data
        std::copy(iv_.begin(), iv_.end(), encrypted_data_with_iv.begin());

        // Encrypt the data
        AES_cbc_encrypt(padded_data.data(), encrypted_data_with_iv.data() + AES_BLOCK_SIZE,
                        padded_data.size(), &encrypt_key, iv_.data(), AES_ENCRYPT);

        // Encrypt the AES key using RSA
        std::vector<unsigned char> encrypted_aes_key(RSA_size(rsa_public_key_));
        if (RSA_public_encrypt(aes_key_.size(), aes_key_.data(), encrypted_aes_key.data(), rsa_public_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error encrypting AES key: " + get_openssl_error());
        }

        // Combine encrypted AES key and encrypted payload
        std::vector<unsigned char> combined_encrypted_data;
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_aes_key.begin(), encrypted_aes_key.end());
        combined_encrypted_data.insert(combined_encrypted_data.end(), encrypted_data_with_iv.begin(), encrypted_data_with_iv.end());

        // Encode the combined data to Base64
        return custom_base64_encode(combined_encrypted_data);
    }

    std::string decrypt_payload(const std::string& encrypted_data) {
        std::vector<unsigned char> combined_encrypted_data = custom_base64_decode(encrypted_data);

        size_t aes_key_size = RSA_size(rsa_private_key_);
        std::vector<unsigned char> encrypted_aes_key(combined_encrypted_data.begin(), combined_encrypted_data.begin() + aes_key_size);
        std::vector<unsigned char> encrypted_data_with_iv(combined_encrypted_data.begin() + aes_key_size, combined_encrypted_data.end());

        std::vector<unsigned char> decrypted_aes_key(aes_key_.size());
        if (RSA_private_decrypt(encrypted_aes_key.size(), encrypted_aes_key.data(), decrypted_aes_key.data(), rsa_private_key_, RSA_PKCS1_OAEP_PADDING) == -1) {
            throw std::runtime_error("Error decrypting AES key: " + get_openssl_error());
        }

        AES_KEY decrypt_key;
        if (AES_set_decrypt_key(decrypted_aes_key.data(), 256, &decrypt_key) != 0) {
            throw std::runtime_error("Error setting AES decryption key: " + get_openssl_error());
        }

        std::vector<unsigned char> iv(AES_BLOCK_SIZE);
        std::copy(encrypted_data_with_iv.begin(), encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, iv.begin());
        std::vector<unsigned char> encrypted_data_part(encrypted_data_with_iv.begin() + AES_BLOCK_SIZE, encrypted_data_with_iv.end());

        std::vector<unsigned char> decrypted_data(encrypted_data_part.size());
        AES_cbc_encrypt(encrypted_data_part.data(), decrypted_data.data(), encrypted_data_part.size(), &decrypt_key, iv.data(), AES_DECRYPT);

        return remove_pkcs7_padding(decrypted_data);
    }

    std::string custom_base64_encode(const std::vector<unsigned char>& data) {
        BIO* bio = BIO_new(BIO_s_mem());
        BIO* b64 = BIO_new(BIO_f_base64());
        bio = BIO_push(b64, bio);
        BIO_write(bio, data.data(), data.size());
        BIO_flush(bio);

        BUF_MEM* buffer_ptr;
        BIO_get_mem_ptr(bio, &buffer_ptr);

        std::string encoded(buffer_ptr->data, buffer_ptr->length);
        BIO_free_all(bio);

        return "ENC:" + encoded;
    }

    std::vector<unsigned char> custom_base64_decode(const std::string& data) {
        std::string encoded = data.substr(4); // Remove "ENC:"
        BIO* bio = BIO_new_mem_buf(encoded.data(), encoded.size());
        BIO* b64 = BIO_new(BIO_f_base64());
        bio = BIO_push(b64, bio);

        std::vector<unsigned char> decoded_data(encoded.size());
        int length = BIO_read(bio, decoded_data.data(), decoded_data.size());
        decoded_data.resize(length);
        BIO_free_all(bio);

        return decoded_data;
    }

    std::vector<unsigned char> apply_pkcs7_padding(const std::string& data) {
        size_t block_size = AES_BLOCK_SIZE;
        size_t pad_size = block_size - (data.size() % block_size);
        std::vector<unsigned char> padded_data(data.begin(), data.end());
        padded_data.insert(padded_data.end(), pad_size, static_cast<unsigned char>(pad_size));
        return padded_data;
    }

    std::string remove_pkcs7_padding(const std::vector<unsigned char>& data) {
        size_t pad_size = data.back();
        return std::string(data.begin(), data.end() - pad_size);
    }

    std::string fragment_payload(const std::vector<unsigned char>& payload) {
        size_t fragment_size = rand() % (150 - 50 + 1) + 50;
        std::string fragmented_payload;
        for (size_t i = 0; i < payload.size(); i += fragment_size) {
            size_t end = std::min(payload.size(), i + fragment_size);
            fragmented_payload += std::string(payload.begin() + i, payload.begin() + end) + "\n";
        }
        return fragmented_payload;
    }

    std::string insert_dynamic_dummy_code(const std::string& payload) {
        std::string dummy_code = generate_dynamic_dummy_code();
        return dummy_code + "\n" + payload + "\n" + dummy_code;
    }

    std::string remove_dynamic_dummy_code(const std::string& payload) {
        std::string result;
        size_t pos = 0;
        while ((pos = payload.find('\n', pos)) != std::string::npos) {
            size_t end = payload.find('\n', pos + 1);
            if (end == std::string::npos) end = payload.length();
            std::string line = payload.substr(pos, end - pos);
            if (!is_dynamic_dummy_code(line)) {
                result += line + "\n";
            }
            pos = end;
        }
        return result;
    }

    std::string add_dynamic_behavior(const std::string& payload) {
        std::string behavior = generate_dynamic_behavior_code();
        return behavior + "\n" + payload + "\n" + behavior;
    }

    std::string get_openssl_error() {
        unsigned long err_code = ERR_get_error();
        char err_buf[256];
        ERR_error_string_n(err_code, err_buf, sizeof(err_buf));
        return std::string(err_buf);
    }

    std::string generate_dynamic_dummy_code() {
        return "dummy_code_" + std::to_string(rand() % 1000);
    }

    std::string generate_dynamic_behavior_code() {
        return "behavior_code_" + std::to_string(rand() % 1000);
    }

    bool is_dynamic_dummy_code(const std::string& line) {
        return line.find("dummy_code_") != std::string::npos;
    }
};

int main() {
    // Example usage of the class
    std::vector<unsigned char> aes_key(32); // 256-bit key
    if (!RAND_bytes(aes_key.data(), aes_key.size())) {
        std::cerr << "Error generating random AES key: " << ERR_error_string(ERR_get_error(), nullptr) << std::endl;
        return 1;
    }

    // Assume rsa_public_key and rsa_private_key are already initialized properly
    RSA* rsa_public_key = nullptr; // Load or generate RSA public key
    RSA* rsa_private_key = nullptr; // Load or generate RSA private key

    try {
        PayloadObfuscatorPacker packer(aes_key, rsa_public_key, rsa_private_key);

        std::string payload = "Sensitive data to be obfuscated.";
        std::string obfuscated_payload = packer.obfuscate(payload);
        std::cout << "Obfuscated Payload: " << obfuscated_payload << std::endl;

        std::string deobfuscated_payload = packer.deobfuscate(obfuscated_payload);
        std::cout << "Deobfuscated Payload: " << deobfuscated_payload << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    // Clean up RSA keys and any other allocated resources

    return 0;
}

