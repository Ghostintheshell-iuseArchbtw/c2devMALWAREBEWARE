#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <zlib.h>

class Cryptor {
public:
    Cryptor(const std::string& input, const std::string& output)
        : inputFilePath(input), outputFilePath(output) {}

    void crypt(const std::vector<uint8_t>& key) {
        readFile();
        encryptData(key);
        writeFile();
    }

private:
    std::string inputFilePath;
    std::string outputFilePath;
    std::vector<uint8_t> fileData;
    std::vector<uint8_t> iv;

    void readFile() {
        std::ifstream inputFile(inputFilePath, std::ios::binary);
        if (!inputFile) {
            std::cerr << "Error: Could not open input file for reading\n";
            exit(1);
        }
        fileData.assign((std::istreambuf_iterator<char>(inputFile)),
                        (std::istreambuf_iterator<char>()));
    }

    void writeFile() {
        std::ofstream outputFile(outputFilePath, std::ios::binary);
        if (!outputFile) {
            std::cerr << "Error: Could not open output file for writing\n";
            exit(1);
        }
        
        // Write IV to the beginning of the file
        outputFile.write(reinterpret_cast<const char*>(iv.data()), iv.size());
        outputFile.write(reinterpret_cast<const char*>(fileData.data()), fileData.size());
    }

    void generateIV() {
        iv.resize(AES_BLOCK_SIZE);
        if (!RAND_bytes(iv.data(), AES_BLOCK_SIZE)) {
            std::cerr << "Error: Could not generate AES IV\n";
            exit(1);
        }
    }

    void encryptData(const std::vector<uint8_t>& key) {
        AES_KEY encKey;
        if (AES_set_encrypt_key(key.data(), 128, &encKey) < 0) {
            std::cerr << "Error: Could not set AES encryption key\n";
            exit(1);
        }

        generateIV(); // Generate a random IV for encryption
        std::vector<uint8_t> encryptedData(fileData.size());
        int num = 0;
        AES_cfb128_encrypt(fileData.data(), encryptedData.data(), fileData.size(), &encKey, iv.data(), &num, AES_ENCRYPT);
        fileData.swap(encryptedData);
    }
};

int main(int argc, char* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <input_file> <output_file> <key>\n";
        return 1;
    }

    std::vector<uint8_t> key(argv[3], argv[3] + strlen(argv[3]));
    if (key.size() < 16) {
        key.resize(16, 0); // Pad key to 16 bytes if it's too short
    }

    Cryptor cryptor(argv[1], argv[2]);
    cryptor.crypt(key);

    return 0;
}
